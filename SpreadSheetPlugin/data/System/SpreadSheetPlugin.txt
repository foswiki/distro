%META:TOPICINFO{author="ProjectContributor" date="1751545667" format="1.1" version="1"}%
%META:TOPICPARENT{name="Plugins"}%
---+!! Foswiki Spreadsheet Plugin
%FORMFIELD{"Description"}%

This Plugin adds spreadsheet capabilities to %WIKITOOLNAME% topics. Formulae like ==%<nop>CALC{"$INT(7/3)"}%== are evaluated at page view time. They can be placed in table cells and outside of tables. In other words, this Plugin provides general formula evaluation capability, not just classic spreadsheet functions.

<table><tr><td valign="top">
*Example:*

| *Region:* | *Sales:* |
| Northeast |  320 |
| Northwest |  580 |
| South |  240 |
| Europe |  610 |
| Asia |  220 |
| Total: |  %CALC{"$SUM( $ABOVE() )"}% |

</td><td>&nbsp; &nbsp; &nbsp;</td><td valign="top">
*Interactive example:*

<form name="interactive" action="%SCRIPTURL{view}%/%WEB%/%TOPIC%" method="get">
<noautolink>
Formula: <code>%<nop>CALC{"</code><input type="text" name="formula" size="40" value="%URLPARAM{ "formula" default="$PROPERSPACE(%WIKINAME%)" encode="entity" }%" /><code>"}%</code> &nbsp; <input type="submit" value="Go" /><br />
Result: &nbsp; &nbsp; %CALC{%URLPARAM{ "formula" default="$PROPERSPACE(%WIKINAME%)" }%}%

</noautolink>
</form>
</td></tr><tr><td colspan="3">
The formula next to "Total" is ==%<nop>CALC{"$SUM( $ABOVE() )"}%==. <br /> (you see the formula instead of the sum in case the Plugin is not installed or not enabled.)
</td></tr></table>

%TOC%

---++ Syntax Rules

The action of this Plugin is triggered two macros:
   * The ==%<nop>CALC{"..."}%== macro, which gets rendered according to the built-in function(s) found between the quotes.  This macro processes tables above it on the page, but must not span multiple lines.
   * The ==%<nop>CALCULATE{"..."}%== macro can span multiple lines, but does not process tables on the page.

Unless there is a requirement to process table rows, =%<nop>CALCULATE{"..."}%= is the preferred form of the macro.

For both macros:
   * Built-in function are of format ==$FUNCNAME(parameter)==
   * Functions may be nested, e.g. ==%<nop>CALC{"$SUM( R2:C$COLUMN(0)..R$ROW(-1):C$COLUMN(0) )"}%==
   * Functions are evaluated from left to right, and from inside to outside if nested
   * The function parameter can be text; a mathematical formula; a cell address; or a range of cell addresses
   * Multiple parameters form a list; they are separated by a comma, followed by optional space, e.g. ==%<nop>CALC{"$SUM( 3, 5, 7 )"}%==
   * Strings can be triple-quoted =='''some, string'''==.   This allows commas, parenthesis and newlines to be processed literally, rather than as part of the function syntax.
      * e.g. ==%<nop>CALCULATE{$SUBSTITUTE('''(Almost), every day''', Almost, Mostly)}%== evaluates to:
      * ==%CALCULATE{$SUBSTITUTE('''(Almost), every day''', Almost, Mostly)}%==
   * Formulae can be placed in a FormattedSearch, but the CALCULATE needs to be escaped. Learn how to [[#CalcInFormattedSearch][use a CALCULATE in a formatted search]]
      * Use of CALCULATE is preferred over CALC in formatted search results unless a table is being generated.

   For the ==%<nop>CALC{"..."}%== macro only:
   * A table cell can be addressed as ==R1:C1==. Table address matrix:
     | ==R1:C1== | ==R1:C2== | ==R1:C3== | ==R1:C4== |
     | ==R2:C1== | ==R2:C2== | ==R2:C3== | ==R2:C4== |
   * A table cell range is defined by two cell addresses separated by ==".."==, e.g. "row 1 through 20, column 3" is: ==R1:C3..R20:C3==
   * Lists can refer to table cell ranges, as well as values, e.g. ==%<nop>CALC{"$SUM( 3, 5, $T(R1:C7), R1:C11..R1:C15 )"}%==
   * Formulae can only reference cells in the current or preceeding row of the current table; they may not reference cells below the current table row
   * Formulae can also be placed outside of tables; they can reference cells in the preceeding table

---++ Built-in Functions

Conventions for Syntax:
   * Required parameters are indicated in ==( bold )==
   * Optional parameters are indicated in ==( _bold italic_ )==

#FuncABOVE
---+++ ABOVE( ) -- address range of cells above the current cell
   * Syntax: ==$ABOVE( )==
   * Example: ==%<nop>CALC{"$SUM($ABOVE())"}%== returns the sum of cells above the current cell
   * Related: =[[#FuncLEFT][$LEFT()]]=, =[[#FuncRIGHT][$RIGHT()]]=

#FuncABS
---+++ ABS( num ) -- absolute value of a number
   * Syntax: ==$ABS( num )==
   * Example: ==%<nop>CALC{"$ABS(-12.5)"}%== returns ==12.5==
   * Related: =[[#FuncSIGN][$SIGN()]]=, =[[#FuncEVEN][$EVEN()]]=, =[[#FuncODD][$ODD()]]=

#FuncAND
---+++ AND( list ) -- logical AND of a list
   * Syntax: ==$AND( list )==
   * Example: ==%<nop>CALC{"$AND(1, 0, 1)"}%== returns ==0==
   * Related: =[[#FuncNOT][$NOT()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncOR][$OR()]]=

#FuncAVERAGE
---+++ AVERAGE( list ) -- average of a list or a range of cells
   * Syntax: ==$AVERAGE( list )==
   * Example: ==%<nop>CALC{"$AVERAGE(R2:C5..R$ROW(-1):C5)"}%== returns the average of column 5, excluding the title row
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncMAX][$MAX()]]=, =[[#FuncMEDIAN][$MEDIAN()]]=, =[[#FuncMIN][$MIN()]]=

#FuncBIN2DEC
---+++ !BIN2DEC( num ) -- convert a binary number to decimal
   * Syntax: ==$BIN2DEC( num )==
   * Note: If the number contains invalid characters, they are removed, and the remaining bits are converted.
   * Example: ==%<nop>CALCULATE{$BIN2DEC(1100100)}%== returns ==100==
   * Example: ==%<nop>CALCULATE{$BIN2DEC(A121)}%== returns ==3==.  (The A and * 2 are removed, resulting in =BIN2DEC(11)=. )
   * Related: =[[#FuncDEC2BIN][$DEC2BIN()]]=, =[[#FuncDEC2HEX][$DEC2HEX()]]=, =[[#FuncDEC2OCT][$DEC2OCT()]]=, =[[#FuncHEX2DEC][$HEX2DEC()]]=, =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncHEXENCODE][$HEXENCODE()]]=, =[[#FuncOCT2DEC][$OCT2DEC()]]=

#FuncBITXOR
---+++ <s>BITXOR( text ) or</s>  BITXOR( integer, list ) -- bit-wise XOR
This function has two modes of operation.
   * If passed a list,  performs a bit-wise XOR of the integers in the list.
      * Syntax: ==$BITXOR( integer, list )==
      * Example: ==%<nop>CALC{"$BITXOR(7, 12)")% returns ==3== ( b0111 xor b1100 = b0011 )

   * *Deprecated,  no longer functional* If passed a character string, operates in TWiki compatbility, performing a bitwise NOT operation on the string
      * Each bit of each character of =text= is flipped, useful to obfuscate text. Bit-XORing text twice will restore the original text.
      * Syntax: ==$BITXOR( text )==
      * Example: ==%<nop>CALC{"$BITXOR(A123)"}%== returns ==&Yuml;&Icirc;&Iacute;&Igrave;==
      * Example: ==%<nop>CALC{"$BITXOR($BITXOR(anything))"}%== returns ==anything==
   * Related: =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncHEXENCODE][$HEXENCODE()]]=, =[[#FuncLEFTTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=, =[[#FuncXOR][$XOR()]]=

#FuncCEILING
---+++ CEILING( num ) -- return the smallest integer following a number
   * The ceiling(x) is the smallest integer not less than x
   * Use =$INT()= to truncate a number towards zero; use =$FLOOR()= to get the largest previous integer
   * Syntax: ==$CEILING( num )==
   * Example: ==%<nop>CALC{"$CEILING(5.4)"}%== returns ==6==
   * Example: ==%<nop>CALC{"$CEILING(-5.4)"}%== returns ==-5==
   * Related: =[[#FuncEVAL][$EVAL()]]=, =[[#FuncFLOOR][$FLOOR()]]=, =[[#FuncINT][$INT()]]=, =[[#FuncROUND][$ROUND()]]=, =[[#FuncVALUE][$VALUE()]]=

#FuncCHAR
---+++ CHAR( number ) -- ASCII character represented by number
   * Syntax: ==$CHAR( number )==
   * Example: Example: ==%<nop>CALC{"$CHAR(97)"}%== returns ==a==
   * Related: =[[#FuncCODE][$CODE()]]=

#FuncCODE
---+++ CODE( text ) -- ASCII numeric value of character
   * The ASCII numeric value of the first character in text
   * Syntax: ==$CODE( text )==
   * Example: ==%<nop>CALC{"$CODE(abc)"}%== returns ==97==
   * Related: =[[#FuncCHAR][$CHAR()]]=

#FuncCOLUMN
---+++ COLUMN( offset ) -- current column number
   * The current table column number with an optional offset
   * Syntax: ==$COLUMN( _offset_ )==
   * Example: ==%<nop>CALC{"$COLUMN()"}%== returns ==2== for the second column
   * Related: =[[#FuncROW][$ROW()]]=, =[[#FuncT][$T()]]=

#FuncCOUNTITEMS
---+++ COUNTITEMS( list ) -- count individual items in a list
   * Syntax: ==$COUNTITEMS( list )==
   * Example: ==%<nop>CALC{"$COUNTITEMS($ABOVE())"}%== returns ==Closed: 1, Open: 2== assuming one cell above the current cell contains ==Closed== and two cells contain ==Open==
   * Related: =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=

#FuncCOUNTSTR
---+++ COUNTSTR( list, str ) -- count the number of cells in a list equal to a given string
   * Count the number of cells in a list equal to a given string (if str is specified), or counts the number of non empty cells in a list
   * Syntax: ==$COUNTSTR( list, _str_ )==
   * Example: ==%<nop>CALC{"$COUNTSTR($ABOVE())"}%== counts the number of non empty cells above the current cell
   * Example: ==%<nop>CALC{"$COUNTSTR($ABOVE(), DONE)"}%== counts the number of cells equal to ==DONE==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncLIST][$LIST()]]=

#FuncDEC2BIN
---+++ !DEC2BIN( num, width ) -- convert a decimal number to binary
   * Syntax: ==$DEC2BIN( num, _width_ )==
   * Note: Invalid decimal values return '0'
   * Example: ==%<nop>CALCULATE{$DEC2BIN(100)}%== returns ==1100100==
   * Example: ==%<nop>CALCULATE{$DEC2BIN(9, 6)}%== returns ==001001==
   * Example: ==%<nop>CALCULATE{$DEC2BIN(A4)}%== returns ==0==
   * Related: =[[#FuncBIN2DEC][$BIN2DEC()]]=, =[[#FuncDEC2HEX][$DEC2HEX()]]=, =[[#FuncDEC2OCT][$DEC2OCT()]]=, =[[#FuncHEX2DEC][$HEX2DEC()]]=, =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncHEXENCODE][$HEXENCODE()]]=, =[[#FuncOCT2DEC][$OCT2DEC()]]=

#FuncDEC2HEX
---+++ !DEC2HEX( num, width ) -- convert a decimal number to hexadecimal
   * Syntax: ==$DEC2HEX( num, _width_ )==
   * Note: Invalid decimal values return '0'
   * Example: ==%<nop>CALCULATE{$DEC2HEX(165)}%== returns ==A5==
   * Example: ==%<nop>CALCULATE{$DEC2HEX(100, 4)}%== returns ==0064==
   * Example: ==%<nop>CALCULATE{$DEC2HEX(A4)}%== returns ==0==
   * Related: =[[#FuncBIN2DEC][$BIN2DEC()]]=, =[[#FuncDEC2BIN][$DEC2BIN()]]=, =[[#FuncDEC2OCT][$DEC2OCT()]]=, =[[#FuncHEX2DEC][$HEX2DEC()]]=, =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncHEXENCODE][$HEXENCODE()]]=, =[[#FuncOCT2DEC][$OCT2DEC()]]=

#FuncDEC2OCT
---+++ !DEC2OCT( num, width ) -- convert a decimal number to octal
   * Syntax: ==$DEC2OCT( num, _width_ )==
   * Note: Invalid decimal values return '0'
   * Example: ==%<nop>CALCULATE{$DEC2OCT(58)}%== returns ==72==
   * Example: ==%<nop>CALCULATE{$DEC2OCT(58, 4)}%== returns ==0072==
   * Example: ==%<nop>CALCULATE{$DEC2OCT(A4)}%== returns ==0==
   * Related: =[[#FuncBIN2DEC][$BIN2DEC()]]=, =[[#FuncDEC2BIN][$DEC2BIN()]]=, =[[#FuncDEC2HEX][$DEC2HEX()]]=, =[[#FuncHEX2DEC][$HEX2DEC()]]=, =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncHEXENCODE][$HEXENCODE()]]=, =[[#FuncOCT2DEC][$OCT2DEC()]]=

#FuncDEF
---+++ DEF( list ) -- find first non-empty list item or cell
   * Returns the first list item or cell reference that is not empty
   * Syntax: ==$DEF( list )==
   * Example: ==%<nop>CALC{"$DEF(R1:C1..R1:C3)"}%==
   * Related: =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLIST][$LIST()]]=

#FuncEMPTY
---+++ EMPTY( text ) -- test for empty text
   * Returns ==1== if =text= is empty, or ==0== if not
   * Syntax: ==$EMPTY( _text_ )==
   * Example: ==%<nop>CALC{"$EMPTY(foo)"}%== returns ==0==
   * Example: ==%<nop>CALC{"$EMPTY()"}%== returns ==1==
   * Example: ==%<nop>CALC{"$EMPTY($TRIM( ))"}%== returns ==1==
   * Related: =[[#FuncEXACT][$EXACT()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncTRIM][$TRIM()]]=

#FuncEVAL
---+++ EVAL( formula ) -- evaluate a simple mathematical formula
   * Addition, substraction, multiplication, division and modulus of numbers are supported. Any nesting is permitted
   * Numbers may be decimal integers (=1234=), binary integers (=0b1110011=), octal integers (=01234=), hexadecimal integers (=0x1234=) or of exponential notation (=12.34e-56=)
   * Syntax: ==$EVAL( formula )==
   * Example: ==%<nop>CALC{"$EVAL( (5 * 3) / 2 + 1.1 )"}%== returns ==8.6==
   * Related: =[[#FuncCEILING][$CEILING()]]=, =[[#FuncEXEC][$EXEC()]]=,=[[#FuncFLOOR][$FLOOR()]]=,  =[[#FuncINT][$INT()]]=, =[[#FuncMOD][$MOD()]]=, =[[#FuncROUND][$ROUND()]]=, =[[#FuncVALUE][$VALUE()]]=

#FuncEVEN
---+++ EVEN( num ) -- test for even number
   * Syntax: ==$EVEN( num )==
   * Example: ==%<nop>CALC{"$EVEN(2)"}%== returns ==1==
   * Related: =[[#FuncABS][$ABS()]]=, =[[#FuncMOD][$MOD()]]=, =[[#FuncODD][$ODD()]]=, =[[#FuncSIGN][$SIGN()]]=

#FuncEXACT
---+++ EXACT( text1, text2 ) -- compare two text strings
   * Compares two text strings and returns ==1== if they are exactly the same, or ==0== if not
   * Syntax: ==$EXACT( text1, _text2_ )==
   * Example: ==%<nop>CALC{"$EXACT(foo, Foo)"}%== returns ==0==
   * Example: ==%<nop>CALC{"$EXACT(foo, $LOWER(Foo))"}%== returns ==1==
   * Related: =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncTRIM][$TRIM()]]=

#FuncEXEC
---+++ EXEC( formula ) -- execute a spreadsheet formula
   * Execute a spreadsheet formula, typically retrieved from a variable. This can be used to store a formula in a variable once and execute it many times using different parameters.
   * Syntax: ==$EXEC( formula )==
   * Example: ==%<nop>CALC{"$SET(msg, $NOEXEC(Hi $GET(name)))"}%== sets the =msg= variable with raw formula =Hi $GET(name)=
   * Example: ==%<nop>CALC{"$SET(name, Tom) $EXEC($GET(msg))"}%== executes content of =msg= variable and returns =Hi Tom=
   * Example: ==%<nop>CALC{"$SET(name, Jerry) $EXEC($GET(msg))"}%== returns =Hi Jerry=
   * Related: =[[#FuncEVAL][$EVAL()]]=, =[[#FuncGET][$GET()]]=, =[[#FuncNOEXEC][$NOEXEC()]]=, =[[#FuncSET][$SET()]]=

#FuncEXISTS
---+++ EXISTS( topic ) -- check if topic exists
   * Topic can be =TopicName= or a =Web.TopicName=. Current web is used if web is not specified.
   * Syntax: ==$EXISTS( topic )==
   * Example: ==%<nop>CALC{"$EXISTS(<nop>%HOMETOPIC%)"}%== returns ==1==
   * Example: ==%<nop>CALC{"$EXISTS(<nop>ThisDoesNotExist)"}%== returns ==0==
   * Related: =[[#FuncEXACT][$EXACT()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncTRIM][$TRIM()]]=

#FuncEXP
---+++ EXP( num ) -- exponent (e) raised to the power of a number
   * EXP is the inverse of the LN function
   * Syntax: ==$EXP( num )==
   * Example: ==%<nop>CALC{"$EXP(1)"}%== returns ==2.71828182845905==
   * Related: =[[#FuncLN][$LN()]]=, =[[#FuncLOG][$LOG()]]=

#FuncFIND
---+++ FIND( string, text, start ) -- find one string within another string
   * Finds one text =string=, within another =text=, and returns the number of the starting position of =string=, from the first character of =text=. This search is case sensitive and is not a regular expression search; use =$SEARCH()= for regular expression searching. Starting position is 1; a 0 is returned if nothing is matched.
   * Syntax: ==$FIND( string, text, _start_ )==
   * Example: ==%<nop>CALC{"$FIND(f, fluffy)"}%== returns ==1==
   * Example: ==%<nop>CALC{"$FIND(f, fluffy, 2)"}%== returns ==4==
   * Example: ==%<nop>CALC{"$FIND(@, fluffy, 1)"}%== returns ==0==
   * Related: =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncSEARCH][$SEARCH()]]=

#FuncFILTER
---+++ FILTER( expression, text ) -- filter out characters from text
   * Remove characters from a =text= string. The filter is applied multiple times.
   * The =expression= can be a sequence of characters or a %SYSTEMWEB%.RegularExpression. Use tokens in the =expression= if needed: =$comma= for comma, =$sp= for space. The =text= may contain commas.
   * Syntax: ==$FILTER( chars, text )==
   * Example: ==%<nop>CALCULATE{$FILTER(f, fluffy)}%== returns ==luy== - filter out a character multiple times
   * Example: ==%<nop>CALCULATE{$FILTER(an Franc, San Francisco)}%== returns ==Sisco== - cut a string
   * Example: ==%<nop>CALCULATE{$FILTER($sp, Cat and Mouse)}%== returns ==CatandMouse== - remove all spaces
   * Example: ==%<nop>CALCULATE{$FILTER([^0-9], Project-ID-1234)}%== returns ==1234== - filter in digits, e.g. keep only digits
   * Example: ==%<nop>CALCULATE{$FILTER([^a-zA-Z0-9 ], Stupid mistake*%@^! Fixed)}%== returns ==Stupid mistake Fixed== - keep only alphanumeric characters and spaces
   * Example: ==%<nop>CALCULATE{$FILTER([^a-zA-Z0-9], $PROPER(an EXCELLENT idea.))}%== returns ==AnExcellentIdea== - turn a string into a %SYSTEMWEB%.WikiWord topic name
   * Related: =[[#FuncFIND][$FIND()]]=, =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncPROPER][$PROPER()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSEARCH][$SEARCH()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=, =[[#FuncTRIM][$TRIM()]]=

#FuncFLOOR
---+++ FLOOR( num ) -- return the largest integer preceding a number
   * The floor(x) is the largest integer not greater than x
   * Use =$INT()= to truncate a number towards zero; use =$CEILING()= to get the smallest following integer
   * Syntax: ==$FLOOR( num )==
   * Example: ==%<nop>CALC{"$FLOOR(5.4)"}%== returns ==5==
   * Example: ==%<nop>CALC{"$FLOOR(-5.4)"}%== returns ==-6==
   * Related: =[[#FuncCEILING][$CEILING()]]=, =[[#FuncEVAL][$EVAL()]]=, =[[#FuncINT][$INT()]]=, =[[#FuncROUND][$ROUND()]]=, =[[#FuncVALUE][$VALUE()]]=

#FuncFORMAT
---+++ FORMAT( type, precision, number ) -- format a number to a certain type and precision
   * Supported =type=:
      * =COMMA= for comma format, such as =12,345.68=
      * =DOLLAR= for Dollar format, such as =$12,345.68=
      * =KB= for Kilo Byte format, such as =1205.63 KB=
      * =MB= for Mega Byte format, such as =1.18 MB=
      * =KBMB= for Kilo/Mega/Giga/Tera Byte auto-adjust format
      * =NUMBER= for number, such as =12345.7=
      * =PERCENT= for percent format, such as =12.3%=
   * The =precision= indicates the the number of digits after the dot
   * Syntax: ==$FORMAT( type, prec, number )==
   * Example: ==%<nop>CALC{"$FORMAT(COMMA, 2, 12345.6789)"}%== returns ==12,345.68==
   * Example: ==%<nop>CALC{"$FORMAT(DOLLAR, 2, 12345.67)"}%== returns ==$12,345.67==
   * Example: ==%<nop>CALC{"$FORMAT(KB, 2, 1234567)"}%== returns ==1205.63 KB==
   * Example: ==%<nop>CALC{"$FORMAT(MB, 2, 1234567)"}%== returns ==1.18 MB==
   * Example: ==%<nop>CALC{"$FORMAT(KBMB, 2, 1234567)"}%== returns ==1.18 MB==
   * Example: ==%<nop>CALC{"$FORMAT(KBMB, 2, 1234567890)"}%== returns ==1.15 GB==
   * Example: ==%<nop>CALC{"$FORMAT(NUMBER, 1, 12345.67)"}%== returns ==12345.7==
   * Example: ==%<nop>CALC{"$FORMAT(PERCENT, 1, 0.1234567)"}%== returns ==12.3%==
   * Related: =[[#FuncFORMATTIME][$FORMATTIME()]]=, =[[#FuncFORMATTIMEDIFF][$FORMATTIMEDIFF()]]=, =[[#FuncROUND][$ROUND()]]=

#FuncFORMATGMTIME
---+++ FORMATGMTIME( serial, text ) -- convert a serialized date into a GMT date string
   * The date string represents the time in Greenwich time zone. Same variable expansion as in =$FORMATTIME()=.
   * Syntax: ==$FORMATGMTIME( serial, text )==
   * Example: ==%<nop>CALC{"$FORMATGMTIME(1041379200, $day $mon $year)"}%== returns ==01 Jan 2003==
   * Related: =[[#FuncFORMATTIME][$FORMATTIME()]]=, =[[#FuncFORMATTIMEDIFF][$FORMATTIMEDIFF()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncTIMEADD][$TIMEADD()]]=, =[[#FuncTIMEDIFF][$TIMEDIFF()]]=, =[[#FuncTODAY][$TODAY()]]=

#FuncFORMATTIME
---+++ FORMATTIME( serial, text ) -- convert a serialized date into a date string
   * The following formatting tokens in =text= are expanded: Date is assumed to be server time; add =GMT= to indicate Greenwich time zone.
      * =$second= - seconds, 00..59
      * =$minute= - minutes, 00..59
      * =$hour= - hours, 00..23
      * =$day= - day of month, 01..31
      * =$month= - month, 01..12
      * =$mon= - month in text format, Jan..Dec
      * =$year= - 4 digit year, 1999
      * =$ye= - 2 digit year, 99
      * =$wd= - day number of the week, 1 for Sunday, 2 for Monday, etc
      * =$wday= - day of the week, Sun..Sat
      * =$weekday= - day of the week, Sunday..Saturday
      * =$yearday= - day of the year, 1..365, or 1..366 in leap years
      * =$isoweek= - ISO 8601 week number, one or two digits, 1..53 - *Caution:* for correct ISO date calculations, specify GMT in the format string or use =%<nop>FORMATGMTIME%=!
      * =$isoweek(format)= - formatted [[http://en.wikipedia.org/wiki/ISO_8601#Week_dates][ISO 8601 week number]]. These variables are expanded in =format=:
         * =$isoweek($year)= - year of ISO 8601 week number, such as =2009= for 2010-01-03
         * =$isoweek($wk)= - 2 digit ISO 8601 week number, such as =53= for 2010-01-03
         * =$isoweek($day)= - day of ISO 8601 week number, starting with 1 for Monday, such as =7= for 2010-01-03
         * =$isoweek($iso)= - full year-week ISO week number, such as =2009-W53= for 2010-01-03
         * =$isoweek($yearW$wk$day)= - full year-week-day ISO week number, such as =2009W537= for 2010-01-03
         * =$isoweek($year-W$wk-$day)= - full year-week-day ISO week number, such as =2009-W53-7= for 2010-01-03
         * =$isoweek($year-W$wk)= - year-week ISO 8601 week number, such as =2009-W53= for 2010-01-03
   * Syntax: ==$FORMATTIME( serial, text )==
   * Example: ==%<nop>CALC{"$FORMATTIME(0, $year/$month/$day GMT)"}%== returns ==1970/01/01 GMT==
   * Example: ==%<nop>CALC{$FORMATTIME($TIME(2005-01-01 GMT), $isoweek($year-W$wk-$day) GMT)}%== returns ==2004-W53-6 GMT==
   * Related: =[[#FuncFORMATGMTIME][$FORMATGMTIME()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncFORMATTIMEDIFF][$FORMATTIMEDIFF()]]=, =[[#FuncTIMEADD][$TIMEADD()]]=, =[[#FuncTIMEDIFF][$TIMEDIFF()]]=, =[[#FuncTODAY][$TODAY()]]=

#FuncFORMATTIMEDIFF
---+++ FORMATTIMEDIFF( unit, precision, time ) -- convert elapsed time to a string
   * Convert elapsed =time= to a human readable format, such as: =12 hours and 3 minutes=
   * The input =unit= can be =second=, =minute=, =hour=, =day=, =month=, =year=. Note: An approximation is used for month and year calculations.
   * The =precision= indicates the number of output units to use
   * Syntax: ==$FORMATTIMEDIFF( unit, precision, time )==
   * Example: ==%<nop>CALC{"$FORMATTIMEDIFF(min, 1, 200)"}%== returns ==3 hours==
   * Example: ==%<nop>CALC{"$FORMATTIMEDIFF(min, 2, 200)"}%== returns ==3 hours and 20 minutes==
   * Example: ==%<nop>CALC{"$FORMATTIMEDIFF(min, 1, 1640)"}%== returns ==1 day==
   * Example: ==%<nop>CALC{"$FORMATTIMEDIFF(min, 2, 1640)"}%== returns ==1 day and 3 hours==
   * Example: ==%<nop>CALC{"$FORMATTIMEDIFF(min, 3, 1640)"}%== returns ==1 day, 3 hours and 20 minutes==
   * Related: =[[#FuncFORMATTIME][$FORMATTIME()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncTIMEADD][$TIMEADD()]]=, =[[#FuncTIMEDIFF][$TIMEDIFF()]]=

#FuncGET
---+++ GET( name ) -- get the value of a previously set variable
   * Specify the variable name (alphanumeric characters and underscores). An empty string is returned if the variable does not exist. Use =$SET()= to set a variable first. Unlike table ranges, variables live for the time of the page view and persist across tables, i.e. you can use it to summarize results across several tables.
   * Syntax: ==$GET( name )==
   * Example: ==%<nop>CALC{"$GET(my_total)"}%== returns the value of the =my_total= variable
   * Related: =[[#FuncEXEC][$EXEC()]]=, =[[#FuncNOEXEC][$NOEXEC()]]=, =[[#FuncSET][$SET()]]=, =[[#FuncSETIFEMPTY][$SETIFEMPTY()]]=, =[[#FuncSETM][$SETM()]]=

#FuncHEX2DEC
---+++ !HEX2DEC( num ) -- convert a hexadecimal number to decimal
   * Syntax: ==$HEX2DEC( num )==
   * Note: Invalid characters are removed and the remaining characters are converted.
   * Example: ==%<nop>CALCULATE{$HEX2DEC(A5)}%== returns ==165==
   * Example: ==%<nop>CALCULATE{$HEX2DEC(1G5)}%== returns ==21==  (Calculates decimal of hex 15.)
   * Related: =[[#FuncBIN2DEC][$BIN2DEC()]]=, =[[#FuncDEC2BIN][$DEC2BIN()]]=, =[[#FuncDEC2HEX][$DEC2HEX()]]=, =[[#FuncDEC2OCT][$DEC2OCT()]]=, =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncHEXENCODE][$HEXENCODE()]]=, =[[#FuncOCT2DEC][$OCT2DEC()]]=

#FuncHEXDECODE
---+++ HEXDECODE( hexcode ) -- convert hexadecimal code to string
   * Decode a hexadecimal string, typically encoded with $HEXENCODE().
   * Syntax: ==$HEXDECODE( hexcode )==
   * Example: ==%<nop>CALC{"$HEXDECODE(687474703A2F2F666F7377696B692E6F72672F)"}%== returns ==http://foswiki.org/==
   * Related: =[[#FuncHEXENCODE][$HEXENCODE()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncHEXENCODE
---+++ HEXENCODE( text ) -- encode text into hexadecimal code
   * Each character of =text= is encoded into two hexadecimal numbers.
   * Syntax: ==$HEXENCODE( text )==
   * Example: ==%<nop>CALC{"$HEXENCODE(<nop>http://foswiki.org/)"}%== returns ==687474703A2F2F666F7377696B692E6F72672F==
   * Related: =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncIF
---+++ IF( condition, value if true, value if 0 ) -- return a value based on a condition
   * The condition can be a number (where ==0== means condition not met), or two numbers with a comparison operator ==&lt;== (less than), ==&lt;=<nop>== (less than or equal), ==<nop>==<nop>== (equal), ==<nop>!=<nop>== (not equal), ==&gt;=<nop>== (greater than or equal), ==&gt;== (greater than).
   * Syntax: ==$IF( condition, value if true, value if 0 )==
   * Example: ==%<nop>CALC{"$IF($T(R1:C5) > 1000, Over Budget, OK)"}%== returns ==Over Budget== if value in R1:C5 is over 1000, ==OK== if not
   * Example: ==%<nop>CALC{"$IF($EXACT($T(R1:C2),), empty, $T(R1:C2))"}%== returns the content of R1:C2 or ==empty== if empty
   * Example: ==%<nop>CALC{"$SET(val, $IF($T(R1:C2) == 0, zero, $T(R1:C2)))"}%== sets a variable conditionally
   * Related: =[[#FuncAND][$AND()]]=, =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncNOT][$NOT()]]=, =[[#FuncOR][$OR()]]=

#FuncINSERTSTRING
---+++ INSERTSTRING( text, start, new ) -- insert a string into a text string
   * Insert =new= string into text string =text= to the right of =start= position. Position starts at 0 (insert before first character). Use a negative =start= to count from the end of the text. If =start= is greater than the length of the =text= the original text is returned.
   * Syntax: ==$INSERTSTRING( text, start, new )==
   * Example: ==%<nop>CALC{"$INSERTSTRING(abcdefg, 2, XYZ)"}%== returns ==abXYZcdefg==
   * Example: ==%<nop>CALC{"$INSERTSTRING(abcdefg, -2, XYZ)"}%== returns ==abcdeXYZfg==
   * Related: =[[#FuncFIND][$FIND()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSEARCH][$SEARCH()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncINT
---+++ INT( formula ) -- evaluate formula and round down to nearest integer
   * Addition, substraction, multiplication, division and modulus of numbers are supported. Any nesting is permitted
   * Numbers may be decimal integers (=1234=), binary integers (=0b1110011=), octal integers (=01234=), hexadecimal integers (=0x1234=) or of exponential notation (=12.34e-56=)
   * If you expect a single decimal integer value with leading zeros, use ==$INT( $VALUE( number ) )==
   * Syntax: ==$INT( formula )==
   * Example: ==%<nop>CALC{"$INT(10 / 4)"}%== returns ==2==
   * Example: ==%<nop>CALC{"$INT($VALUE(09))"}%== returns ==9==
   * Related: =[[#FuncCEILING][$CEILING()]]=, =[[#FuncEVAL][$EVAL()]]=, =[[#FuncFLOOR][$FLOOR()]]=, =[[#FuncROUND][$ROUND()]]=, =[[#FuncVALUE][$VALUE()]]=

#FuncISDIGIT
---+++ ISDIGIT( text ) -- test for digits
   * Test for one or more digits (0...9)
   * Syntax: ==$ISDIGIT( text )==
   * Example: ==%<nop>CALCULATE{$ISDIGIT(123)}%== returns ==1==
   * Example: ==%<nop>CALCULATE{$ISDIGIT(-7)}%== returns ==0==
   * Related: =[[#FuncABS][$ABS()]]=, =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEVEN][$EVEN()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncISDIGIT][$ISDIGIT()]]=, =[[#FuncMOD][$MOD()]]=, =[[#FuncODD][$ODD()]]=, =[[#FuncSIGN][$SIGN()]]=, =[[#FuncVALUE][$VALUE()]]=

#FuncISLOWER
---+++ ISLOWER( text ) -- test for lower case text
   * Syntax: ==$ISLOWER( text )==
   * Example: ==%<nop>CALCULATE{$ISLOWER(apple)}%== returns ==1==
   * Example: ==%<nop>CALCULATE{$ISLOWER(apple tree)}%== returns ==0== (text contains a space character)
   * Example: ==%<nop>CALCULATE{$ISLOWER(ORANGE)}%== returns ==0==
   * Related: =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncLOWER][$LOWER()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncISDIGIT][$ISDIGIT()]]=, =[[#FuncISUPPER][$ISUPPER()]]=, =[[#FuncISWIKIWORD][$ISWIKIWORD()]]=, =[[#FuncUPPER][$UPPER()]]=

#FuncISUPPER
---+++ ISUPPER( text ) -- test for upper case text
   * Can be used to test for ACRONYMS
   * Syntax: ==$ISUPPER( text )==
   * Example: ==%<nop>CALCULATE{$ISUPPER(apple)}%== returns ==0==
   * Example: ==%<nop>CALCULATE{$ISUPPER(ORANGE)}%== returns ==1==
   * Example: ==%<nop>CALCULATE{$ISUPPER(ORANGE GARDEN)}%== returns ==0== (text contains a space character)
   * Related: =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncLOWER][$LOWER()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncISDIGIT][$ISDIGIT()]]=, =[[#FuncISLOWER][$ISLOWER()]]=, =[[#FuncISWIKIWORD][$ISWIKIWORD()]]=, =[[#FuncUPPER][$UPPER()]]=

#FuncISWIKIWORD
---+++ ISWIKIWORD( text ) -- test for !WikiWord
   * A %SYSTEMWEB%.WikiWord has a sequence of UPPER, lower/digit, UPPER, optional mixed case alphanumeric characters
   * Can be used together with =$ISUPPER()= to test for valid topic names
   * Syntax: ==$ISWIKIWORD( text )==
   * Example: ==%<nop>CALCULATE{$ISWIKIWORD(<nop>GoldenGate)}%== returns ==1==
   * Example: ==%<nop>CALCULATE{$ISWIKIWORD(whiteRafting)}%== returns ==0==
   * Related: =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEXISTS][$EXISTS()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncISDIGIT][$ISDIGIT()]]=, =[[#FuncISLOWER][$ISLOWER()]]=, =[[#FuncISUPPER][$ISUPPER()]]=, =[[#FuncPROPER][$PROPER()]]=, =[[#FuncPROPERSPACE][$PROPERSPACE()]]=

#FuncLEFT
---+++ LEFT( ) -- address range of cells to the left of the current cell
   * Syntax: ==$LEFT( )==
   * Example: ==%<nop>CALC{"$SUM($LEFT())"}%== returns the sum of cells to the left of the current cell
   * Related: =[[#FuncABOVE][$ABOVE()]]=, =[[#FuncRIGHT][$RIGHT()]]=

#FuncLEFTSTRING
---+++ LEFTSTRING( text, num ) -- extract characters at the beginning of a text string
   * Retrieve the =num= of characters from the left end of =text=. The leftmost character is returned if =num= is missing. If =num= is greater than the length of =text= the entire text string is returned with no additional spaces added. If =num= is negative =num= characters are removed from the end of the string. If =num= is zero or =num= is a negative value with the number greater than the length of =text= an empty string is returned.
   * Syntax: ==$LEFTSTRING( text, _num_ )==
   * Example: ==%<nop>CALC{"$LEFTSTRING(abcdefg)"}%== returns ==a==
   * Example: ==%<nop>CALC{"$LEFTSTRING(abcdefg, 0)"}%== returns an empty string.
   * Example: ==%<nop>CALC{"$LEFTSTRING(abcdefg, 5)"}%== returns ==abcde==
   * Example: ==%<nop>CALC{"$LEFTSTRING(abcdefg, 12)"}%== returns ==abcdefg==
   * Example: ==%<nop>CALC{"$LEFTSTRING(abcdefg, -3)"}%== returns ==abcd==
   * Example: ==%<nop>CALC{"$LEFTSTRING(abcdefg, -12)"}%== returns an empty string.
   * Related: =[[#FuncFIND][$FIND()]]=, =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSEARCH][$SEARCH()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncLENGTH
---+++ LENGTH( text ) -- length of text in bytes
   * Syntax: ==$LENGTH( text )==
   * Example: ==%<nop>CALC{"$LENGTH(abcd)"}%== returns ==4==
   * Related: =[[#FuncLISTSIZE][$LISTSIZE()]]=

#FuncLIST
---+++ LIST( range ) -- convert content of a cell range into a list
   * Convert the content of a range of cells into a flat list, delimited by comma. Cells containing commas are merged into the list
   * Syntax: ==$LIST( range )==
   * Example: ==%<nop>CALC{"$LIST($LEFT())"}%== returns ==Apples, Lemons, Oranges, Kiwis== assuming the cells to the left contain ==| Apples | Lemons, Oranges | Kiwis |==
   * Related: =[[#FuncAVERAGE][$AVERAGE()]]=, =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncDEF][$DEF()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTJOIN][$LISTJOIN()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTRAND][$LISTRAND()]]=, =[[#FuncLISTREVERSE][$LISTREVERSE()]]=, =[[#FuncLISTSHUFFLE][$LISTSHUFFLE()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTTRUNCATE][$LISTTRUNCATE()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncMAX][$MAX()]]=, =[[#FuncMEDIAN][$MEDIAN()]]=, =[[#FuncMIN][$MIN()]]=, =[[#FuncPRODUCT][$PRODUCT()]]=, =[[#FuncSPLIT][$SPLIT()]]=, =[[#FuncSUM][$SUM()]]=, =[[#FuncSUMDAYS][$SUMDAYS()]]=, =[[#FuncSUMPRODUCT][$SUMPRODUCT()]]=

#FuncLISTEACH
---+++ LISTEACH( formula, list ) -- evaluate and update each element of a list
   * In the formula you can use ==$item== to indicate the element; ==$index== to show the index of the list, starting at 1. If ==$item== is omitted, the item is appended to the formula.
   * Syntax: ==$LISTEACH( formula, list )==
   * Example: ==%<nop>CALC{"$LISTEACH($index: $EVAL(2 * $item), 3, 5, 7, 11)"}%== returns ==1: 6, 2: 10, 3: 14, 4: 22==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTREVERSE][$LISTREVERSE()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTIF
---+++ LISTIF( condition, list ) -- remove elements from a list that do not meet a condition
   * In addition to the condition described in =[[#FuncIF][$IF()]]=, you can use ==$item== to indicate the current element, and ==$index== for the list index, starting at 1
   * Syntax: ==$LISTIF( condition, list )==
   * Example: ==%<nop>CALC{"$LISTIF($item > 12, 14, 7, 25)"}%== returns ==14, 25==
   * Example: ==%<nop>CALC{"$LISTIF($NOT($EXACT($item,)), A, B, , E)"}%== returns non-empty elements ==A, B, E==
   * Example: ==%<nop>CALC{"$LISTIF($index > 2, A, B, C, D)"}%== returns ==C, D==
   * Related: =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTREVERSE][$LISTREVERSE()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTITEM
---+++ LISTITEM( index, list ) -- get one element of a list
   * Index is 1 to size of list; use a negative number to count from the end of the list
   * Syntax: ==$LISTITEM( index, list )==
   * Example: ==%<nop>CALC{"$LISTITEM(2, Apple, Orange, Apple, Kiwi)"}%== returns ==Orange==
   * Example: ==%<nop>CALC{"$LISTITEM(-1, Apple, Orange, Apple, Kiwi)"}%== returns ==Kiwi==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTRAND][$LISTRAND()]]=, =[[#FuncLISTREVERSE][$LISTREVERSE()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTJOIN
---+++ LISTJOIN( separator, list ) -- convert a list into a string
   * By default, list items are separated by a comma and a space. Use this function to indicate a specific =separator= string, which may include =$comma= for comma, =$n= for newline, =$sp= for space, and =$nop= for no separator between list items.
   * Syntax: ==$LISTJOIN( separator, list )==
   * Example: ==%<nop>CALC{"$LISTJOIN($n, Apple, Orange, Apple, Kiwi)"}%== returns the four items separated by new lines
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncSPLIT][$SPLIT()]]=

#FuncLISTMAP
---+++ LISTMAP( formula, list ) -- evaluate and update each element of a list
   * Note: LISTMAP has been renamed to LISTEACH.  LISTMAP is retained for compatibility.
   * Related: =[[#FuncLISTEACH][$LISTEACH()]]=

#FuncLISTNONEMPTY
---+++ LISTNONEMPTY( list ) -- remove all empty elements from a list
   * Syntax: ==$LISTNONEMPTY( list )==
   * Example: ==%<nop>CALC{"$LISTNONEMPTY(, Apple, Orange, , Kiwi)"}%== returns ==Apple, Orange, Kiwi==
   * Related: =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=

#FuncLISTRAND
---+++ LISTRAND( list ) -- get one random element of a list
   * Syntax: ==$LISTRAND( list )==
   * Example: ==%<nop>CALC{"$LISTRAND(Apple, Orange, Apple, Kiwi)"}%== returns one of the four elements
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTSHUFFLE][$LISTSHUFFLE()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncRAND][$RAND()]]=, =[[#FuncRAND][$RANDSTRING()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTREVERSE
---+++ LISTREVERSE( list ) -- opposite order of a list
   * Syntax: ==$LISTREVERSE( list )==
   * Example: ==%<nop>CALC{"$LISTREVERSE(Apple, Orange, Apple, Kiwi)"}%== returns ==Kiwi, Apple, Orange, Apple==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTSIZE
---+++ LISTSIZE( list ) -- number of elements in a list
   * Syntax: ==$LISTSIZE( list )==
   * Example: ==%<nop>CALC{"$LISTSIZE(Apple, Orange, Apple, Kiwi)"}%== returns ==4==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTJOIN][$LISTJOIN()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTREVERSE][$LISTREVERSE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTTRUNCATE][$LISTTRUNCATE()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncSPLIT][$SPLIT()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTSHUFFLE
---+++ LISTSHUFFLE( list ) -- shuffle element of a list in random order
   * Syntax: ==$LISTSHUFFLE( list )==
   * Example: ==%<nop>CALC{"$LISTSHUFFLE(Apple, Orange, Apple, Kiwi)"}%== returns the four elements in random order
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTRAND][$LISTRAND()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncRAND][$RAND()]]=, =[[#FuncRAND][$RANDSTRING()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTSORT
---+++ LISTSORT( list ) -- sort a list
   * Sorts a list in ASCII order, or numerically if all elements are numeric
   * Syntax: ==$LISTSORT( list )==
   * Example: ==%<nop>CALC{"$LISTSORT(Apple, Orange, Apple, Kiwi)"}%== returns ==Apple, Apple, Kiwi, Orange==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTREVERSE][$LISTREVERSE()]]=, =[[#FuncLISTSHUFFLE][$LISTSHUFFLE()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTTRUNCATE
---+++ LISTTRUNCATE( size, list ) -- truncate list to size
   * Specify the desired size of the list; use a negative number to count from the end of the list
   * Syntax: ==$LISTTRUNCATE( size, list )==
   * Example: ==%<nop>CALC{"$LISTTRUNCATE(2, Apple, Orange, Kiwi)"}%== returns ==Apple, Orange==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncLISTUNIQUE][$LISTUNIQUE()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLISTUNIQUE
---+++ LISTUNIQUE( list ) -- remove all duplicates from a list
   * Syntax: ==$LISTUNIQUE( list )==
   * Example: ==%<nop>CALC{"$LISTUNIQUE(Apple, Orange, Apple, Kiwi)"}%== returns ==Apple, Orange, Kiwi==
   * Related: =[[#FuncCOUNTITEMS][$COUNTITEMS()]]=, =[[#FuncCOUNTSTR][$COUNTSTR()]]=, =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncLISTITEM][$LISTITEM()]]=, =[[#FuncLISTEACH][$LISTEACH()]]=, =[[#FuncLISTREVERSE][$LISTREVERSE()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=, =[[#FuncLISTSORT][$LISTSORT()]]=, =[[#FuncSUM][$SUM()]]=

#FuncLN
---+++ LN( num ) -- natural logarithm of a number
   * LN is the inverse of the EXP function
   * Syntax: ==$LN( num )==
   * Example: ==%<nop>CALC{"$LN(10)"}%== returns ==2.30258509299405==
   * Related: =[[#FuncEXP][$EXP()]]=, =[[#FuncLOG][$LOG()]]=

#FuncLOG
---+++ LOG( num, base ) -- logarithm of a number to a given base
   * base-10 logarithm of a number (if base is 0 or not specified), else logarithm of a number to the given base
   * Syntax: ==$LOG( num, _base_ )==
   * Example: ==%<nop>CALC{"$LOG(1000)"}%== returns ==3==
   * Example: ==%<nop>CALC{"$LOG(16, 2)"}%== returns ==4==
   * Related: =[[#FuncEXP][$EXP()]]=, =[[#FuncLN][$LN()]]=

#FuncLOWER
---+++ LOWER( text ) -- lower case string of a text
   * Syntax: ==$LOWER(text)==
   * Example: ==%<nop>CALC{"$LOWER( $T(R1:C5) )"}%== returns the lower case string of the text in cell ==R1:C5==
   * Related: =[[#FuncPROPER][$PROPER()]]=, =[[#FuncPROPERSPACE][$PROPERSPACE()]]=, =[[#FuncTRIM][$TRIM()]]=, =[[#FuncUPPER][$UPPER()]]=

#FuncMAX
---+++ MAX( list ) - biggest value of a list or range of cells
   * Syntax: ==$MAX( list )==
   * Example: To find the biggest number to the left of the current cell, write: ==%<nop>CALC{"$MAX($LEFT())"}%==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncMEDIAN][$MEDIAN()]]=, =[[#FuncMIN][$MIN()]]=, =[[#FuncPERCENTILE][$PERCENTILE()]]=

#FuncMEDIAN
---+++ MEDIAN( list ) -- median of a list or range of cells
   * Syntax: ==$MEDIAN( list )==
   * Example: ==%<nop>CALC{"$MEDIAN(3, 9, 4, 5)"}%== returns ==4.5==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncMAX][$MAX()]]=, =[[#FuncMIN][$MIN()]]=, =[[#FuncPERCENTILE][$PERCENTILE()]]=

#FuncMIN
---+++ MIN( list ) -- smallest value of a list or range of cells
   * Syntax: ==$MIN( list )==
   * Example: ==%<nop>CALC{"$MIN(15, 3, 28)"}%== returns ==3==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncMAX][$MAX()]]=, =[[#FuncMEDIAN][$MEDIAN()]]=, =[[#FuncPERCENTILE][$PERCENTILE()]]=

#FuncMOD
---+++ MOD( num, divisor ) -- residual amount after dividing ==num== by ==divisor==
   * Syntax: ==$MOD( num, divisor )==
   * Example: ==%<nop>CALC{"$MOD(7, 3)"}%== returns ==1==
   * Related: =[[#FuncEVAL][$EVAL()]]=

#FuncNOEXEC
---+++ NOEXEC( formula ) -- do not execute a spreadsheet formula
   * Prevent a formula from getting executed. This is typically used to store a raw formula in a variable for later use as described in =[[#FuncEXEC][$EXEC()]]=.
   * Syntax: ==$NOEXEC( formula )==
   * Example: ==%<nop>CALC{"$SET(msg, $NOEXEC(Hi $GET(name)))"}%== sets the =msg= variable with the formula =Hi $GET(name)= without executing it
   * Related: =[[#FuncEVAL][$EVAL()]]=, =[[#FuncEXEC][$EXEC()]]=, =[[#FuncGET][$GET()]]=, =[[#FuncSET][$SET()]]=

#FuncNOP
---+++ NOP( text ) -- no-operation
   * Useful to change the order of Plugin execution. For example, it allows preprossing to be done before =%<nop>SEARCH{}%= is evaluated. The percent character '%' can be escaped with =$per=
   * Syntax: ==$NOP( text )==

#FuncNOT
---+++ NOT( num ) -- reverse logic of a number
   * Returns 0 if ==num== is not zero, 1 if zero
   * Syntax: ==$NOT( num )==
   * Example: ==%<nop>CALC{"$NOT(0)"}%== returns ==1==
   * Related: =[[#FuncAND][$AND()]]=, =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncOR][$OR()]]=

#FuncOCT2DEC
---+++ !OCT2DEC( num ) -- convert an octal number to decimal
   * Syntax: ==$OCT2DEC( num )==
   * Note: Invalid characters are removed, and the remaining characters are converted to decimal.
   * Example: ==%<nop>CALCULATE{$OCT2DEC(54)}%== returns ==44==
   * Example: ==%<nop>CALCULATE{$OCT2DEC(1G5)}%== returns ==13== (Decimal value of octal 15 )
   * Related: =[[#FuncBIN2DEC][$BIN2DEC()]]=, =[[#FuncDEC2BIN][$DEC2BIN()]]=, =[[#FuncDEC2HEX][$DEC2HEX()]]=, =[[#FuncDEC2OCT][$DEC2OCT()]]=, =[[#FuncHEX2DEC][$HEX2DEC()]]=, =[[#FuncHEXDECODE][$HEXDECODE()]]=, =[[#FuncHEXENCODE][$HEXENCODE()]]=

#FuncODD
---+++ ODD( num ) -- test for odd number
   * Syntax: ==$ODD( num )==
   * Example: ==%<nop>CALC{"$ODD(2)"}%== returns ==0==
   * Related: =[[#FuncABS][$ABS()]]=, =[[#FuncEVEN][$EVEN()]]=, =[[#FuncMOD][$MOD()]]=, =[[#FuncSIGN][$SIGN()]]=

#FuncOR
---+++ OR( list ) -- logical OR of a list
   * Syntax: ==$OR( list )==
   * Example: ==%<nop>CALC{"$OR(1, 0, 1)"}%== returns ==1==
   * Related: =[[#FuncAND][$AND()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncNOT][$NOT()]]=

#FuncPERCENTILE
---+++ PERCENTILE( num, list ) -- percentile of a list or range of cells
   * Calculates the num-th percentile, useful to establish a threshold of acceptance. num is the percentile value, range 0..100
   * Syntax: ==$PERCENTILE( num, list )==
   * Example: ==%<nop>CALC{"$PERCENTILE(75, 400, 200, 500, 100, 300)"}%== returns ==450==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncMAX][$MAX()]]=, =[[#FuncMEDIAN][$MEDIAN()]]=, =[[#FuncMIN][$MIN()]]=

#FuncPI
---+++ PI( ) -- mathematical constant Pi, 3.14159265358979
   * Syntax: ==$PI( )==
   * Example: ==%<nop>CALC{"$PI()"}%== returns ==3.14159265358979==

#FuncPRODUCT
---+++ PRODUCT( list ) -- product of a list or range of cells
   * Syntax: ==$PRODUCT( list )==
   * Example: To calculate the product of the cells to the left of the current one use ==%<nop>CALC{"$PRODUCT($LEFT())"}%==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncPRODUCT][$PRODUCT()]]=, =[[#FuncSUM][$SUM()]]=, =[[#FuncSUMPRODUCT][$SUMPRODUCT()]]=

#FuncPROPER
---+++ PROPER( text ) -- properly capitalize text
   * Capitalize letters that follow any character other than a letter; convert all other letters to lowercase letters
   * Syntax: ==$PROPER( text )==
   * Example: ==%<nop>CALC{"$PROPER(a small STEP)"}%== returns ==A Small Step==
   * Example: ==%<nop>CALC{"$PROPER(f1 (formula-1))"}%== returns ==F1 (Formula-1)==
   * Related: =[[#FuncLOWER][$LOWER()]]=, =[[#FuncPROPERSPACE][$PROPERSPACE()]]=, =[[#FuncTRIM][$TRIM()]]=, =[[#FuncUPPER][$UPPER()]]=

#FuncPROPERSPACE
---+++ PROPERSPACE( text ) -- properly space out <nop>WikiWords
   * Properly spaces out %SYSTEMWEB%.WikiWords preceeded by white space, parenthesis, or ==][==. Words listed in the DONTSPACE %SYSTEMWEB%.%WIKIPREFSTOPIC% variable or DONTSPACE Plugins setting are excluded
   * Syntax: ==$PROPERSPACE( text )==
   * Example: Assuming DONTSPACE contains <nop>MacDonald: ==%<nop>CALC{"$PROPERSPACE(Old <nop>MacDonald had a <nop>ServerFarm, <nop>EeEyeEeEyeOh)"}%== returns ==Old <nop>MacDonald had a Server Farm, Ee Eye Ee Eye Oh==
   * Related: =[[#FuncLOWER][$LOWER()]]=, =[[#FuncPROPER][$PROPER()]]=, =[[#FuncTRIM][$TRIM()]]=, =[[#FuncUPPER][$UPPER()]]=

#FuncRAND
---+++ RAND( max ) -- random number
   * Random number, evenly distributed between 0 and ==max==, or 0 and 1 if max is not specified
   * Syntax: ==$RAND( max )==
   * Related: =[[#FuncEVAL][$EVAL()]]=, =[[#FuncLISTRAND][$LISTRAND()]]=, =[[#FuncLISTSHUFFLE][$LISTSHUFFLE()]]=

#FuncRANDSTRING
---+++ RANDSTRING( set, format ) -- random string & password generator
   * Generate a random string from a ==set== of characters; the set may contain sequences like ==a..z==; default is ==a..zA..Z0..9_==. The ==format== defines the string length or the output format; specify a number to indicate the length of the random string; default is ==8== characters. Alternatively, specify a format string with ==x== as placeholders for random characters, such ==xxxx-xxxx-xxxx-xxxx==.
   * Syntax: ==$RANDSTRING( _set_, _format_ )==
   * Example: ==%<nop>CALCULATE{$RANDSTRING()}%== returns a random string with 8 characters composed of alphanumeric characters and underscores
   * Example: ==%<nop>CALCULATE{$RANDSTRING(A..NP..Z1..9, xxxx-xxxx-xxxx-xxxx)}%== returns four sets of random strings, separated by dashes, where each set has four characters composed of uppercase letters and numbers, excluding letter O and number 0
   * Related: =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncLISTRAND][$LISTRAND()]]=, =[[#FuncLISTSHUFFLE][$LISTSHUFFLE()]]=, =[[#FuncRAND][$RAND()]]=, =[[#FuncRAND][$RANDSTRING()]]=, =[[#FuncREPEAT][$REPEAT()]]=

#FuncREPEAT
---+++ REPEAT( text, num ) -- repeat text a number of times
   * Syntax: ==$REPEAT( text, num )==
   * Example: ==%<nop>CALC{"$REPEAT(/\, 5)"}%== returns ==/\/\/\/\/\==

#FuncREPLACE
---+++ REPLACE( text, start, num, new ) -- replace part of a text string
   * Replace =num= number of characters of text string =text=, starting at =start=, with new text =new=. Starting position is 1; use a negative =start= to count from the end of the text.  In the =new= parameter you can write =$comma= to escape comma, =$sp= to escape space.
   * Syntax: ==$REPLACE( text, start, num, new )==
   * Example: ==%<nop>CALC{"$REPLACE(abcdefghijk, 6, 5, *)"}%== returns ==abcde*k==
   * Example: ==%<nop>CALC{"$REPLACE(abcdefghijk, 6, 5, $comma)"}%== returns ==abcde,k==
   * Example: ==%<nop>CALC{"$REPLACE(abcdefghijk, 6, 5, $sp)"}%== returns ==abcde k==
   * Related: =[[#FuncFIND][$FIND()]]=, =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSEARCH][$SEARCH()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncRIGHT
---+++ RIGHT( ) -- address range of cells to the right of the current cell
   * Syntax: ==$RIGHT( )==
   * Example: ==%<nop>CALC{"$SUM($RIGHT())"}%== returns the sum of cells to the right of the current cell
   * Related: =[[#FuncABOVE][$ABOVE()]]=, =[[#FuncLEFT][$LEFT()]]=

#FuncRIGHTSTRING
---+++ RIGHTSTRING( text, num ) -- extract characters at the end of a text string. =num= must be a positive number. Negative values of =num= are interpreted as zero. If =num= is larger than the length of the text the entire text is returned with no additional spaces.
   * Retrieve the =num= of characters from the right end of =text=. The rightmost character is returned if =num= is missing.
   * Syntax: ==$RIGHTSTRING( text, _num_ )==

   * Example: ==%<nop>CALC{"$RIGHTSTRING(abcdefg)"}%== returns ==g==
   * Example: ==%<nop>CALC{"$RIGHTSTRING(abcdefg, 0)"}%== returns an empty string
   * Example: ==%<nop>CALC{"$RIGHTSTRING(abcdefg, 5)"}%== returns ==cdefg==
   * Example: ==%<nop>CALC{"$RIGHTSTRING(abcdefg, 10)"}%== returns ==abcdefg==
   * Example: ==%<nop>CALC{"$RIGHTSTRING(abcdefg, -2)"}%== returns an empty string

   * Related: =[[#FuncFIND][$FIND()]]=, =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncSEARCH][$SEARCH()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncROUND
---+++ ROUND( formula, digits ) -- round a number
   * Evaluates a simple ==formula== and rounds the result up or down to the number of digits if ==digits== is positive; to the nearest integer if digits is missing; or to the left of the decimal point if digits is negative
   * Syntax: ==$ROUND( formula, digits )==
   * Example: ==%<nop>CALC{"$ROUND(3.15, 1)"}%== returns ==3.2==
   * Example: ==%<nop>CALC{"$ROUND(3.149, 1)"}%== returns ==3.1==
   * Example: ==%<nop>CALC{"$ROUND(-2.475, 2)"}%== returns ==-2.48==
   * Example: ==%<nop>CALC{"$ROUND(34.9, -1)"}%== returns ==30==
   * Related: =[[#FuncCEILING][$CEILING()]]=, =[[#FuncEVAL][$EVAL()]]=, =[[#FuncFLOOR][$FLOOR()]]=, =[[#FuncINT][$INT()]]=, =[[#FuncFORMAT][$FORMAT()]]=

#FuncROW
---+++ ROW( offset ) -- current row number
   * The current table row number with an optional offset
   * Syntax: ==$ROW( _offset_ )==
   * Example: To get the number of rows excluding table heading (first row) and summary row (last row you are in), write: ==%<nop>CALC{"$ROW(-2)"}%==
   * Related: =[[#FuncCOLUMN][$COLUMN()]]=, =[[#FuncT][$T()]]=

#FuncSEARCH
---+++ SEARCH( string, text, start ) -- search a string within a text
   * Finds one text =string=, within another =text=, and returns the number of the starting position of =string=, from the first character of =text=. This search is a %SYSTEMWEB%.RegularExpression search; use =$FIND()= for non-regular expression searching. Starting position is 1; a 0 is returned if nothing is matched
   * Syntax: ==$SEARCH( string, text, _start_ )==
   * Example: ==%<nop>CALC{"$SEARCH([uy], fluffy)"}%== returns ==3==
   * Example: ==%<nop>CALC{"$SEARCH([uy], fluffy, 4)"}%== returns ==6==
   * Example: ==%<nop>CALC{"$SEARCH([abc], fluffy,)"}%== returns ==0==
   * Related: =[[#FuncFIND][$FIND()]]=, =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=

#FuncSET
---+++ SET( name, value ) -- set a variable for later use
   * Specify the variable name (alphanumeric characters and underscores) and the value. The value may contain a formula; formulae are evaluated before the variable assignment; see =[[#FuncNOEXEC][$NOEXEC()]]= if you want to prevent that. This function returns no output. Use =$GET()= to retrieve variables. Unlike table ranges, variables live for the time of the page view and persist across tables, i.e. you can use it to summarize results across several tables and also across included topics
   * Syntax: ==$SET( name, value )==
   * Example: ==%<nop>CALC{"$SET(my_total, $SUM($ABOVE()))"}%== sets the =my_total= variable to the sum of all table cells located above the current cell and returns an empty string
   * Related: =[[#FuncEXEC][$EXEC()]]=, =[[#FuncGET][$GET()]]=, =[[#FuncNOEXEC][$NOEXEC()]]=, =[[#FuncSETIFEMPTY][$SETIFEMPTY()]]=, =[[#FuncSETM][SETM()]]=

#FuncSETIFEMPTY
---+++ SETIFEMPTY( name, value ) -- set a variable only if empty
   * Specify the variable name (alphanumeric characters and underscores) and the value.
   * Syntax: ==$SETIFEMPTY( name, value )==
   * Example: ==%<nop>CALC{"$SETIFEMPTY(result, default)"}%== sets the =result= variable to =default= if the variable is empty or 0; in any case an empty string is returned
   * Related: =[[#FuncGET][$GET()]]=, =[[#FuncSET][$SET()]]=

#FuncSETM
---+++ SETM( name, formula ) -- update an existing variable based on a formula
   * Specify the variable name (alphanumeric characters and underscores) and the formula. The formula must start with an operator to ==+== (add), ==-== (subtract), ==*== (multiply), or ==/== (divide) something to the variable. This function returns no output. Use =$GET()= to retrieve variables
   * Syntax: ==$SETM( name, formula )==
   * Example: ==%<nop>CALC{"$SETM(total, + $SUM($LEFT()))"}%== adds the sum of all table cells on the left to the =total= variable, and returns an empty string
   * Related: =[[#FuncGET][$GET()]]=, =[[#FuncSET][$SET()]]=, =[[#FuncSETIFEMPTY][$SETIFEMPTY()]]=

#FuncSIGN
---+++ SIGN( num ) -- sign of a number
   * Returns -1 if ==num== is negative, 0 if zero, or 1 if positive
   * Syntax: ==$SIGN( num )==
   * Example: ==%<nop>CALC{"$SIGN(-12.5)"}%== returns ==-1==
   * Related: =[[#FuncABS][$ABS()]]=, =[[#FuncEVAL][$EVAL()]]=, =[[#FuncEVEN][$EVEN()]]=, =[[#FuncINT][$INT()]]=, =[[#FuncNOT][$NOT()]]=, =[[#FuncODD][$ODD()]]=

#FuncSPLIT
---+++ SPLIT( separator, text ) -- split a string into a list
   * Split =text= into a list using =separator= as a delimiter. The =separator= may be a regular expression and may include =$comma= for comma, =$sp= for space and =$empty= to split at each character. Default separator is one or more spaces (=$sp$sp*=). Leading and trailing spaces are removed from the string before splitting.
   * Syntax: ==$SPLIT( separator, text )==
   * Example: ==%<nop>CALC{"$SPLIT(, Apple Orange   Kiwi)"}%== returns ==Apple, Orange, Kiwi==
   * Example: ==%<nop>CALC{"$SPLIT($comma, Apple Orange Kiwi)"}%== returns ==Apple, Orange, Kiwi==
   * Example: ==%<nop>CALC{"$SPLIT(-, Apple-Orange-Kiwi)"}%== returns ==Apple, Orange, Kiwi==
   * Example: ==%<nop>CALC{"$SPLIT([-:]$sp*, Apple-Orange: Kiwi)"}%== returns ==Apple, Orange, Kiwi== (the separator means: Dash or colon, followed by optional spaces
   * Example: ==%<nop>CALC{"$SPLIT($empty, Apple)"}%== returns ==A, p, p, l, e==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncLISTJOIN][$LISTJOIN()]]=, =[[#FuncLISTSIZE][$LISTSIZE()]]=

#FuncSQRT
---+++ SQRT( num ) -- square root of a number
   * Syntax: ==$SQRT( num )==
   * Example: ==%<nop>CALC{"$SQRT(16)"}%== returns ==4==

#FuncSUBSTITUTE
---+++ SUBSTITUTE( text, old, new, instance, option ) -- substitute text
   * Substitutes =new= text for =old= text in a =text= string. =instance= specifies which occurance of =old= you want to replace. If you specify =instance=, only that instance is replaced. Otherwise, every occurance is changed to the new text. The text may not contain commas. In the =old= and =new= parameters you can write =$comma= to escape comma, =$sp= to escape space. A literal search is performed by default; a %SYSTEMWEB%.RegularExpression search if the =option= is set to ==r==
   * Syntax: ==$SUBSTITUTE( text, old, _new_, _instance_, _option_ )==
   * Example: ==%<nop>CALC{"$SUBSTITUTE(Good morning, morning, day)"}%== returns ==Good day==
   * Example: ==%<nop>CALC{"$SUBSTITUTE(Q2-2002, 2, 3)"}%== returns ==Q3-3003==
   * Example: ==%<nop>CALC{"$SUBSTITUTE(Q2-2002,2, 3, 3)"}%== returns ==Q2-2003==
   * Example: ==%<nop>CALC{"$SUBSTITUTE(Q2-2002, -, $comma)"}%== returns ==Q2,2002==
   * Example: ==%<nop>CALC{"$SUBSTITUTE(abc123def, [0-9], 9, , r)"}%== returns ==abc999def==
   * Related: =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncSUBSTRING
---+++ SUBSTRING( text, start, num ) -- extract a substring out of a text string
   * Extract =num= number of characters of text string =text=, starting at =start=. Starting position is 1; use a negative =start= to count from the end of the text. If =start= or =num= is zero an empty string is returned. If =num= is greater than the length of the =text= the entire text string is returned without any extra spaces added.
   * Syntax: ==$SUBSTRING( text, start, num )==
   * Example: ==%<nop>CALC{"$SUBSTRING(abcdefghijk, 3, 5)"}%== returns ==cdefg==
   * Example: ==%<nop>CALC{"$SUBSTRING(abcdefghijk, 3, 20)"}%== returns ==cdefghijk==
   * Example: ==%<nop>CALC{"$SUBSTRING(abcdefghijk, -5, 3)"}%== returns ==ghi==
   * Related: =[[#FuncFIND][$FIND()]]=, =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSEARCH][$SEARCH()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=, =[[#FuncTRANSLATE][$TRANSLATE()]]=

#FuncSUM
---+++ SUM( list ) -- sum of a list or range of cells
   * Syntax: ==$SUM( list )==
   * Example: To sum up column 5 excluding the title row, write ==%<nop>CALC{"$SUM(R2:C5..R$ROW(-1):C5)"}%== in the last row; or simply ==%<nop>CALC{"$SUM($ABOVE())"}%==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncPRODUCT][$PRODUCT()]]=, =[[#FuncSUMPRODUCT][$SUMPRODUCT()]]=, =[[#FuncWORKINGDAYS][$WORKINGDAYS()]]=

#FuncSUMDAYS
---+++ SUMDAYS( list ) -- sum the days in a list or range of cells
   * The total number of days in a list or range of cells containing numbers of hours, days or weeks. The default unit is days; units are indicated by a ==h==, ==hours==, ==d==, ==days==, ==w==, ==weeks== suffix. One week is assumed to have 5 working days, one day 8 hours
   * Syntax: ==$SUMDAYS( list )==
   * Example: ==%<nop>CALC{"$SUMDAYS(2w, 1, 2d, 4h)"}%== returns ==13.5==, the evaluation of =(2*5 + 1 + 2 + 4/8)=
   * Related: =[[#FuncSUM][$SUM()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncFORMATTIME][$FORMATTIME()]]=

#FuncSUMPRODUCT
---+++ SUMPRODUCT( list, list ) -- scalar product on ranges of cells
   * Syntax: ==$SUMPRODUCT( list, list, _list..._ )==
   * Example: ==%<nop>CALC{"$SUMPRODUCT(R2:C1..R4:C1, R2:C5..R4:C5)"}%== evaluates and returns the result of ==($T(R2:C1) * $T(R2:C5) + $T(R3:C1) * $T(R3:C5) + $T(R4:C1) * $T(R4:C5))==
   * Related: =[[#FuncLIST][$LIST()]]=, =[[#FuncPRODUCT][$PRODUCT()]]=, =[[#FuncSUM][$SUM()]]=

#FuncT
---+++ T( address ) -- content of a cell
   * Syntax: ==$T( address )==
   * Example: ==%<nop>CALC{"$T(R1:C5)"}%== returns the text in cell ==R1:C5==
   * Related: =[[#FuncCOLUMN][$COLUMN()]]=, =[[#FuncROW][$ROW()]]=

#FuncTRANSLATE
---+++ TRANSLATE( text, from, to ) -- translate text from one set of characters to another
   * The translation is done =from= a set =to= a set, one character by one. The =text= may contain commas; all three parameters are required. In the =from= and =to= parameters you can write =$comma= to escape comma, =$sp= to escape space
   * Syntax: ==$TRANSLATE( text, from, to )==
   * Example: ==%<nop>CALC{"$TRANSLATE(boom,bm,cl)"}%== returns ==cool==
   * Example: ==%<nop>CALC{"$TRANSLATE(one, two,$comma,;)"}%== returns ==one; two==
   * Related: =[[#FuncINSERTSTRING][$INSERTSTRING()]]=, =[[#FuncLEFTSTRING][$LEFTSTRING()]]=, =[[#FuncREPLACE][$REPLACE()]]=, =[[#FuncRIGHTSTRING][$RIGHTSTRING()]]=, =[[#FuncSUBSTRING][$SUBSTRING()]]=, =[[#FuncSUBSTITUTE][$SUBSTITUTE()]]=

#FuncTIME
---+++ TIME( text ) -- convert a date string into a serialized date number
   * Serialized date is seconds since the Epoch, e.g. midnight, 01 Jan 1970. Current time is taken if the date string is empty. Supported date formats: =31 Dec 2009=; =31 Dec 2009 GMT=; =31 Dec 2009 LOCAL=; =31 Dec 09=; =31-Dec-2009=; =31/Dec/2009=; =2009/12/31=; =2009-12-31=; =2009/12/31=; =2009/12/31 23:59=; =2009/12/31 - 23:59=; =2009-12-31-23-59=; =2009/12/31 - 23:59:59=; =2009.12.31.23.59.59=. DOY (Day of Year) formats: =DOY2003.365=, =DOY2003.365.23.59=, =DOY2003.365.23.59.59=.
   * Note: Date is assumed to be GMT unless SPREADSHEETPLUGIN_TIMEISLOCAL is set (default 0). Add =GMT= to force Greenwich time zone. Add =LOCAL= to force the timezone of the server. Note that if you use LOCAL or SPREADSHEETPLUGIN_TIMEISLOCAL is set to 1, dates entered by users on servers placed to the east of Greenwich will be converted to the day before which will often be undesired. It is recommended to keep SPREADSHEETPLUGIN_TIMEISLOCAL = 0 which is the default.
   * Syntax: ==$TIME( _text_ )==
   * Example: ==%<nop>CALC{"$TIME(2003/10/14 GMT)"}%== returns ==1066089600==
   * Related: =[[#FuncFORMATGMTIME][$FORMATGMTIME()]]=, =[[#FuncFORMATTIME][$FORMATTIME()]]=, =[[#FuncFORMATTIMEDIFF][$FORMATTIMEDIFF()]]=, =[[#FuncTIMEADD][$TIMEADD()]]=, =[[#FuncTIMEDIFF][$TIMEDIFF()]]=, =[[#FuncTODAY][$TODAY()]]=, =[[#FuncWORKINGDAYS][$WORKINGDAYS()]]=

#FuncTIMEADD
---+++ TIMEADD( serial, value, unit ) -- add a value to a serialized date
   * The =unit= is seconds if not specified; unit can be =second=, =minute=, =hour=, =day=, =week=, =month=, =year=. Note: An approximation is used for month and year calculations
   * Syntax: ==$TIMEADD( serial, value, _unit_ )==
   * Example: ==%<nop>CALC{"$TIMEADD($TIME(), 2, week)"}%== returns the serialized date two weeks from now
   * Related: =[[#FuncFORMATTIME][$FORMATTIME()]]=, =[[#FuncFORMATGMTIME][$FORMATGMTIME()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncTIMEDIFF][$TIMEDIFF()]]=, =[[#FuncTODAY][$TODAY()]]=

#FuncTIMEDIFF
---+++ TIMEDIFF( serial_1, serial_2, unit ) -- time difference between two serialized dates
   * The =unit= is seconds if not specified; unit can be specified as in =$TIMEADD()=. Note: An approximation is used for month and year calculations. Use =$FORMAT()=, =$FORMATTIMEDIFF()= or =$INT()= to format real numbers
   * Syntax: ==$TIMEDIFF( serial_1, serial_2, _unit_ )==
   * Example: ==%<nop>CALC{"$TIMEDIFF($TIME(), $EVAL($TIME()+90), minute)"}%== returns ==1.5==
   * Related: =[[#FuncFORMAT][$FORMAT()]]=, =[[#FuncFORMATGMTIME][$FORMATGMTIME()]]=, =[[#FuncFORMATTIME][$FORMATTIME()]]=, =[[#FuncFORMATTIMEDIFF][$FORMATTIMEDIFF()]]=, =[[#FuncINT][$INT()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncTIMEADD][$TIMEADD()]]=, =[[#FuncTODAY][$TODAY()]]=, =[[#FuncWORKINGDAYS][$WORKINGDAYS()]]=

#FuncTODAY
---+++ TODAY( ) -- serialized date of today at midnight GMT
   * In contrast, the related =$TIME()= returns the serialized date of today at the current time, e.g. it includes the number of seconds since midnight GMT
   * Syntax: ==$TODAY( )==
   * Example: ==%<nop>CALC{"$TODAY()"}%== returns the number of seconds since Epoch
   * Related: =[[#FuncFORMATTIME][$FORMATTIME()]]=, =[[#FuncFORMATGMTIME][$FORMATGMTIME()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncTIMEADD][$TIMEADD()]]=, =[[#FuncTIMEDIFF][$TIMEDIFF()]]=

#FuncTRIM
---+++ TRIM( text ) -- trim spaces from text
   * Removes all spaces from text except for single spaces between words
   * Syntax: ==$TRIM( text )==
   * Example: ==%<nop>CALC{"$TRIM( eat  spaces  )"}%== returns ==eat spaces==
   * Related: =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncPROPERSPACE][$PROPERSPACE()]]=

#FuncUPPER
---+++ UPPER( text ) -- upper case string of a text
   * Syntax: ==$UPPER( text )==
   * Example: ==%<nop>CALC{"$UPPER($T(R1:C5))"}%== returns the upper case string of the text in cell ==R1:C5==
   * Related: =[[#FuncLOWER][$LOWER()]]=, =[[#FuncPROPER][$PROPER()]]=, =[[#FuncPROPERSPACE][$PROPERSPACE()]]=, =[[#FuncTRIM][$TRIM()]]=

#FuncVALUE
---+++ VALUE( text ) -- convert text to number
   * Extracts a number from ==text==. Returns ==0== if not found
   * Syntax: ==$VALUE( text )==
   * Example: ==%<nop>CALC{"$VALUE(US$1,200)"}%== returns ==1200==
   * Example: ==%<nop>CALC{"$VALUE(<nop>PrjNotebook1234)"}%== returns ==1234==
   * Example: ==%<nop>CALC{"$VALUE(Total: -12.5)"}%== returns ==-12.5==
   * Related: =[[#FuncEVAL][$EVAL()]]=, =[[#FuncINT][$INT()]]=

#FuncWHILE
---+++ WHILE( condition, do ) -- do something while a condition is true
   * The =condition= can be a number (where ==0== means condition not met), or two numbers with a comparison operator ==&lt;== (less than), ==&lt;=<nop>== (less than or equal), ==<nop>==<nop>== (equal), ==<nop>!=<nop>== (not equal), ==&gt;=<nop>== (greater than or equal), ==&gt;== (greater than).
   * The =condition= and =do= are evaluated in each cycle; a =$counter= starting at 1 can be used in =condition= and =do=.
   * Syntax: ==$WHILE( condition, do something )==
   * Example: ==|%<nop>CALC{"$WHILE($counter<=10, $counter )"}%|== returns ==|%CALC{"$WHILE($counter<=10, $counter )"}%|== (note trailing space after 10)
   * Example: ==|%<nop>CALC{"$SET(i,0) $WHILE($GET(i) < 10, $SETM(i,+1)$EVAL($GET(i)*$GET(i)), )"}%|== returns <b><tt>|%CALC{"$SET(i,0) $WHILE($GET(i) < 10, $SETM(i,+1)$EVAL($GET(i)*$GET(i)), )"}%|</tt></b> (note trailing space)
   * Related: =[[#FuncAND][$AND()]]=, =[[#FuncEMPTY][$EMPTY()]]=, =[[#FuncEXACT][$EXACT()]]=, =[[#FuncGET][$GET()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncLISTIF][$LISTIF()]]=, =[[#FuncNOT][$NOT()]]=, =[[#FuncOR][$OR()]]=, =[[#FuncSET][$SET()]]=, =[[#FuncSETM][$SETM()]]=, =[[#FuncREPEAT][$REPEAT()]]=

#FuncWORKINGDAYS
---+++ WORKINGDAYS( serial_1, serial_2 ) -- working days between two serialized dates
   * Working days are Monday through Friday (sorry, Israel!). The start date is not included in the count. The end date is concluded. If you need both included simply subtract one day from the start date.
   * Syntax: ==$WORKINGDAYS( serial_1, serial_2 )==
   * Example: ==%<nop>CALC{"$WORKINGDAYS($TIME(2004/07/15), $TIME(2004/08/03))"}%== returns ==13==
   * Related: =[[#FuncSUMDAYS][$SUMDAYS()]]=, =[[#FuncTIME][$TIME()]]=, =[[#FuncTIMEDIFF][$TIMEDIFF()]]=

#FuncXOR
---+++ XOR( list ) -- logical XOR of integers in a list
Each integer is treated as true/false and then logically xor'd together.  The acutal value of the integer other than 0 or non-zero doesn't matter.  Non-integer items in the list are ignored.
   * Syntax: ==$XOR( list )==
   * Example: ==%<nop>CALC{"$XOR(0, 0)"}%== returns ==0==
   * Example: ==%<nop>CALC{"$XOR(0, 1)"}%== returns ==1==
   * Example: ==%<nop>CALC{"$XOR(1, 0)"}%== returns ==1==
   * Example: ==%<nop>CALC{"$XOR(1, 1)"}%== returns ==0==
   * Example: ==%<nop>CALC{"$XOR(1, 0, 1)"}%== returns ==0==
   * Related: =[[#FuncAND][$AND()]]=, =[[#FuncIF][$IF()]]=, =[[#FuncNOT][$NOT()]]=, =[[#FuncOR][$OR()]]=

---++ FAQ

#CalcInFormattedSearch
---+++ Can I use CALCULATE in a formatted search?

Specifically, how can I output some conditional text in a %SYSTEMWEB%.FormattedSearch?

You need to escape the CALCULATE macro so that it executes once per search hit. This can be done by escaping the =%= signs of =%<nop>CALCULATE{...}%= with =$percnt=.
For example, to execute =$IF($EXACT($formfield(Tested), Yes), %<nop>PUBURL%/%<nop>SYSTEMWEB%/DocumentGraphics/choice-yes.gif, %<nop>PUBURL%/%<nop>SYSTEMWEB%/DocumentGraphics/choice-no.gif)= in the =format=""= parameter, write this:

=%<nop>SEARCH{ .... format="| $topic | $percntCALCULATE{$IF($EXACT($formfield(Tested), Yes), %<nop>PUBURL%/%<nop>SYSTEMWEB%/DocumentGraphics/choice-yes.gif, %<nop>PUBURL%/%<nop>SYSTEMWEB%/DocumentGraphics/choice-no.gif)}$percnt |" }%=

<div class='foswikiHelp'>%T% CALC can also be used, but under some conditions
the macro might not be expanded. For best results, use CALCULATE. CALC would
only be recommended if the SEARCH was also outputting a Table.</div>

---+++ How can I easily repeat a formula in a table?

To repeat the same formula in all cells of a table row define the formula once in a preferences setting and use that in the CALC. The preferences setting can be hidden in HTML comments. Example:

<verbatim class="tml">
<!--
   * Set MYFORMULA = $EVAL($SUBSTITUTE(...etc...))
-->
| A | 1 | %CALC{%MYFORMULA%}% |
| B | 2 | %CALC{%MYFORMULA%}% |
| C | 3 | %CALC{%MYFORMULA%}% |
</verbatim>

---++ Bug Tracking Example

| *Bug#:*  | *Priority:* | *Subject:* | *Status:* | *Days to fix* |
| Bug:1231 | Low         | File Open ...       | Open      |  3 |
| Bug:1232 | High        | Memory Window ...   | Fixed     |  2 |
| Bug:1233 | Medium      | Usability issue ... | Assigned  |  5 |
| Bug:1234 | High        | No arrange ...      | Fixed     |  1 |
| Total: %CALC{"$ROW(-2)"}% \
  | %CALC{"$COUNTITEMS( R2:C$COLUMN()..R$ROW(-1):C$COLUMN() )"}% | . \
  | %CALC{"$COUNTITEMS( R2:C$COLUMN()..R$ROW(-1):C$COLUMN() )"}% \
  |  Total: %CALC{"$SUM( R2:C$COLUMN()..R$ROW(-1):C$COLUMN() )"}% |

The last row is defined as:

<verbatim class="tml">
| Total: %CALC{"$ROW(-2)"}% \
  | %CALC{"$COUNTITEMS( R2:C$COLUMN()..R$ROW(-1):C$COLUMN() )"}% | . \
  | %CALC{"$COUNTITEMS( R2:C$COLUMN()..R$ROW(-1):C$COLUMN() )"}% \
  |  Total: %CALC{"$SUM( R2:C$COLUMN()..R$ROW(-1):C$COLUMN() )"}% |
</verbatim>

Above table is created manually. Another Plugin could build the table dynamically, e.g. by pulling data out of a bug tracking system. The Spreadsheet Plugin can be used to display table data statistics.

---++ Settings

You can override some default settings in the plugin by setting the following [[%SYSTEMWEB%.PreferenceSettings][preferences]].
| *Preference* | *Meaning* | *Default* |
| =SPREADSHEETPLUGIN_DEBUG= | \
Debug plugin: (See output in Foswiki logs) | 0 |
| =SPREADSHEETPLUGIN_SKIPINCLUDE= | \
Do not handle =%<nop>CALC{}%= variable in included \
topic while including topic | 1 |
| =SPREADSHEETPLUGIN_DONTSPACE= | Comma-delimited list of \
[[%SYSTEMWEB%.WikiWord][WikiWords]] to exclude from being spaced out by \
the ==$PROPERSPACE(text)== function. | \
<noautolink>CodeWarrior, MacDonald, McIntosh, RedHat, SuSE</noautolink> |
| =SPREADSHEETPLUGIN_TIMEISLOCAL= | \
Makes the TIME function assume input is local time \
and converts the entered time to GMT unless the date has 'GMT' appended. \
Note that this behavior creates problems for users using servers in time zones \
to the east of Greenwich. The setting is present for compatibility. | 0 |
| =SPREADSHEETPLUGIN_ALLOWHTML= | \
Permits =CALC= and =CALCULATE= macros to emit unencoded =&lt;= and =&gt;=. \
If not enabled, =&lt;= will be encoded as =&amp;lt;= and =&gt;= will be encoded as =&amp;gt;= \
It is strongly recommended that this be left undefined or disabled, especially if input \
to the =CALC= / =CALCULATE= Macro includes any =URLPARAM= data. | 0 |

Note that the =DONTSPACE= global preference overrides the =SPREADSHEETPLUGIN_DONTSPACE= preference for historical reasons.

---++ Installation Instructions
%$INSTALL_INSTRUCTIONS%
   * Test if the "Total" in the first table in this topic is correct.

---++ Change History
%TABLE{columnwidths="7em" tablewidth="100%"}%
|  17 May 2023: (1.25) | Foswikitask:Item15192: fixed EVAL feature exposes infromation about paths and files on the server |
|  19 Jul 2018: (1.24) | Foswikitask:Item14741: EVAL(0) should return 0 not the empty string |
|  20 Jan 2017: (1.23) | Released with Foswiki 2.1.3<br />\
                         Foswikitask:Item13892: Clarify documentation on CALC vs. CALCULATE |
|  08 Apr 2016: (1.22) | Foswikitask:Item13883: Fix typo in documentation. |
|  15 Oct 2015: (1.21) | Foswikitask:Item13811: Fixed memory leak using CALCULATE in a persistent perl environment.<br />\
                         Foswikitask:Item13796: Encode &lt; and &gt; when emitted by CALC or CALCULATE. |
|  27 Jul 2015: (1.20) | Copyright update, released with Foswiki 2.0.1 |
|  28 May 2015: (1.19) | Foswikitask:item12739: Added ISDIGIT(), ISLOWER(), ISUPPER(), ISWIKIWORD() and FILTER() functions.<br />\
                  Foswikitask:Item13440: Document issues with BITXOR.  Foswiki unicode core won't support a simple byte based xor of strings. |
|  02 Jan 2015: (1.18) | Foswikitask:Item12739: fixed use of uninitialized value, Add triple-quote for escaped strings,  Add RANDSTRING() function.<br />\
                  Add the base conversion functions: <noautolink> DEC2BIN() BIN2DEC() DEC2HEX() HEX2DEC() DEC2OCT() and OCT2DEC().</noautolink> <br />\
                  Add LISTEACH() as an alias for LISTMAP() |
|  05 Nov 2012: | Foswikitask:Item8417: add VarCALCULATE macro to be used within the normal macro evaluation order. (name chosen for comaptibility ) |
|  15 Oct 2012: | Foswikitask:Item12153: Use proper format of %<nop>SCRIPTURL% in CALC demo. |
|  06 Apr 2012: (1.1.6) | Foswikitask:Item11523 - support $comma, $sp in SUBSTITUTE, REPLACE.<br />\
                  Foswikitask:Item11524 - Add FLOOR and CEILING macros. |
|  17 Jan 2012: (1.1.5) | Foswikitask:Item11450 - ABOVE and LEFT return R0 and C0 respectively.  Should be R1 and C1 |
|  05 Dec 2011: (1.1.4) | Foswiki release 1.1.4 - Foswikitask:Item11079: leading/trailing spaces break $LISTUNIQUE(). <br />\
                  Foswikitask:Item11183: Sync up with TWiki version. <br />\
                  Add $HEXENCODE(), $HEXDECODE(), $BITXOR(), $XOR(). $LISTNONEMPTY(), $SPLIT(), and $WHILE.  <br />\
                  Add Day of Year (DOY) support to $TIME() and $isoweek formats to $FORMATTIME() and $FORMATGMTIME(). |
|  10 Apr 2011: | Version released with Foswiki 1.1.3. Only a minor change related to how the plugin is being upgraded |
|  06 Nov 2010: | Foswikitask:Item9963: Revert usage of =$<nop>percent= back to =$<nop>percnt= |
|  09 Aug 2010: | Foswikitask:Item1998: fix for $RIGHT() inclusion of cells to left as well as right |
|  04 Aug 2010: | Foswikitask:Item9415: Minor documentation updates |
|  21 Jul 2010: | Foswikitask:Item5163: prevent misrendering of empty rows, Foswikitask:Item9400: correct $LIST for cells containing commas, as per doc |
|  29 Dec 2009: | Foswikitask:Item2301: added =$nop= to $LISTJOIN() for better empty parameter |
|  10 Nov 2009: | Added unit tests |
|  27 Oct 2009: | Foswikitask:Item2301: Fixed $LISTJOIN() to accept an empty separator |
|  20 Sep 2009: | Minor documentation update. trunk and release branch code synced (mainly perltidy - all functional changes have been in sync). |
|  17 Sep 2009: | Foswikitask:Item2087: SpreadSheetPlugin forgets about zeros being floats as well |
|  11 May 2009: | Fixed the calculation of WORKINGDAYS. Changed the default behavior of TIME back to not converting dates to GMT as this creates surprising effects for users living to the east of Greenwich. Added SPREADSHEETPLUGIN_TIMEISLOCAL so users depending on the old behavior keep the old behavior if TIME. Added the feature 'local' to TIME so conversion behavior can be used on demand. |
|  22 Apr 2009: | Removed support for settings in the plugin topic which is a bad idea anyway as they get overwritten at each Foswiki upgrade. Define the global settings in <nop>%LOCALSITEPREFS% instead. <br />Foswikitask:Item5471: Fixed replacing 0 in REPLACE. Fixed FIND/SEARCH handling of empty strings and corrected documentation for SEARCH |
|  29 Mar 2009: | Added $EMPTY(), $LEFTSTRING(), $RIGHTSTRING(), SUBSTRING(), and $INSERTSTRING() |
|  06 Jan 2009: | Foswikitask:Item4835: Allow SUBSTITUTE and REPLACE to return values 0 and '' |
|  16 Dec 2008: | Foswiki version - no new features |
|  13 Oct 2007: | Added $FORMATTIMEDIFF() |
|  09 Sep 2007: | Enhanced documentation for $EVAL() and $INT() |
|  02 Jun 2007: | Added %SYSTEMWEB%.VarCALC to have =%<nop>CALC{}%= listed in [[%SYSTEMWEB%.Macros][Macros]] |
|  14 Apr 2007: | Fixing bug in $EXISTS() that required full =web.topic= instead of just =topic= |
|  11 Mar 2007: | Fixing bug in $VALUE() and $INT(), introduced by version 09 Mar 2007 |
|  09 Mar 2007: | Added $EXP(), $LN(), $LOG(), $PI(), $SQRT(); fixed $ROUND() bug, contributed by TWiki:Main/SergejZnamenskij |
|  23 Jan 2007: | Enhanced documentation |
|  18 Dec 2006: | Added $LISTRAND(), $LISTSHUFFLE(), $LISTTRUNCATE(); fixed spurious newline at end of topic, contributed by Foswiki:Main/MichaelDaum |
|  10 Oct 2006: | Enhanced documentation |
|  13 May 2006: | Added $SETIFEMPTY(); fixes in documentation |
|  17 Jun 2005: | Added $NOEXEC(), $EXEC() |
|  25 Mar 2005: | Fixed evaluation bug when using <nop>SpeedyCGI accelerator; code refactor to load module only when needed, contributed by Foswiki:Main/CrawfordCurrie |
|  24 Oct 2004: | Added $EXISTS(), contributed by TWiki:Main/RodrigoChandia; added $PERCENTILE() |
|  18 Oct 2004: | Added $LISTJOIN() |
|  26 Sep 2004: | Added $FORMAT(KB), $FORMAT(MB), contributed by Foswiki:Main/ArthurClemens; added $FORMAT(KBMB), $EVEN(), $ODD() |
|  17 Jul 2004: | Added $WORKINGDAYS(), contributed by Foswiki:Main/CrawfordCurrie |
|  24 May 2004: | Refactored documentation (no code changes) |
|  03 Apr 2004: | Added $ABS(), $LISTIF(); fixed $VALUE() to remove leading zeros; changed $FIND() and $SEARCH() to return 0 instead of empty string if no match |
|  21 Mar 2004: | Added $LISTITEM(); fixed call to unofficial function |
|  16 Mar 2004: | Added $LISTMAP(), $LISTREVERSE(), $LISTSIZE(), $LISTSORT(), $LISTUNIQUE(), $SETM(); retired $COUNTUNIQUE() in favor of $COUNTITEMS($LISTUNIQUE()); fixed evaluation order issue of $IF(); fixed missing eval error messages suppressed since version 06 Mar 2004; redirect stderr messages to warning |
|  08 Mar 2004: | Added $LIST() |
|  06 Mar 2004: | Added $AND(), $MOD(), $NOT(), $OR(), $PRODUCT(), $PROPER(), $PROPERSPACE(), $RAND(), $REPEAT(), $SIGN(), $VALUE(); added digits parameter to $ROUND(); renamed $MULT() to $PRODUCT(); $MULT() is deprecated and undocumented |
|  27 Feb 2004: | Added $COUNTUNIQUE() |
|  24 Oct 2003: | Added $SET(), $GET(), $MEDIAN(); added $SUMPRODUCT(), inspired by TWiki:Main/RobertWithrow; added $SUMDAYS(), contributed by Foswiki:Main/SvenDowideit |
|  21 Oct 2003: | Added support for lists =(1, 2, 3)= and lists of table ranges =(R1:C1..R1:C5, R3:C1..R3:C5)= for all functions that accept a table range; added $TIMEADD(); in $TIMEDIFF() added week unit; in $FORMATTIME() changed $weekday to $wd and added $wday and $weekday |
|  14 Oct 2003: | Added $TIME(), $TODAY(), $FORMATTIME(), $FORMATGMTIME(), $TIMEDIFF() |
|  13 Oct 2003: | Added $MULT(), contributed by TWiki:Main/GerritJanBaarda |
|  30 Jul 2003: | Added $TRANSLATE() |
|  19 Jul 2003: | Added $FIND(), $NOP(), $REPLACE(), $SEARCH(), $SUBSTITUTE(), contributed by TWiki:Main/PaulineCheung |
|  19 Apr 2003: | Added $COUNTSTR(), $EXACT(), $IF(), $ROUND(), $TRIM(); added $FORMAT(), contributed by TWiki:Main/JimStraus; support =%= modulus operator in $EVAL(), $INT(), and $ROUND(); fixed bug in $DEF() |
|  07 Jun 2002: | Added $DEF(), contributed by TWiki:Main/MartinFuzzey; allow values with HTML formatting like =&lt;u&gt;102&lt;/u&gt;=, suggested by TWiki:Main/GladeDiviney; added SKIPINCLUDE setting |
|  12 Mar 2002: | Support for multiple functions per nesting level |
|  15 Jan 2002: | Added $CHAR(), $CODE() and $LENGTH() |
|  12 Nov 2001: | Added $RIGHT() |
|  12 Aug 2001: | Fixed bug of disappearing multi-column cells |
|  19 Jul 2001: | Fixed incorrect $SUM() calculation of cell with value =0= |
|  14 Jul 2001: | Changed to plug & play |
|  01 Jun 2001: | Fixed insecure dependencies for $MIN() and $MAX() |
|  16 Apr 2001: | Fixed div by 0 bug in $AVERAGE() |
|  17 Mar 2001: | Initial version with $ABOVE(), $AVERAGE(), $COLUMN(), $COUNTITEMS(), $EVAL(), $INT(), $LEFT(), $LOWER(), $MAX(), $MIN(), $ROW(), $SUM(), $T(), $UPPER() |

---
*Related Topics:* %SYSTEMWEB%.%WIKIPREFSTOPIC%, %LOCALSITEPREFS%, [[%SYSTEMWEB%.Plugins][Plugins]], %SYSTEMWEB%.VarCALC

%META:FORM{name="PackageForm"}%
%META:FIELD{name="Author" title="Author" value="ProjectContributor"}%
%META:FIELD{name="Copyright" title="Copyright" value="&copy; 2001-2015 Peter Thoeny, TWiki.org, &copy; 2008-2015 TWiki:TWiki.TWikiContributor, &copy; 2015 Wave Systems Corp. &copy; 2008-2015 Foswiki Contributors "}%
%META:FIELD{name="Description" title="Description" value="%25$SHORTDESCRIPTION%25"}%
%META:FIELD{name="Home" title="Home" value="http://foswiki.org/Extensions/%$ROOTMODULE%"}%
%META:FIELD{name="License" title="License" value="GPL ([[http://www.gnu.org/copyleft/gpl.html][GNU General Public License]])"}%
%META:FIELD{name="Release" title="Release" value="%$RELEASE%"}%
%META:FIELD{name="Repository" title="Repository" value="https://github.com/foswiki/distro"}%
%META:FIELD{name="Support" title="Support" value="http://foswiki.org/Support/%$ROOTMODULE%"}%
%META:FIELD{name="Version" title="Version" value="%$VERSION%"}%
%META:PREFERENCE{name="ALLOWTOPICVIEW" title="ALLOWTOPICVIEW" type="Set" value="*"}%
%META:PREFERENCE{name="DENYTOPICVIEW" title="DENYTOPICVIEW" type="Set" value="WikiGuest"}%
%META:PREFERENCE{name="PERMSET_VIEW" title="PERMSET_VIEW" type="Local" value="registeredusers"}%
