#! /usr/bin/perl -wT
# -d:NYTProf
# See bottom of file for license and copyright information

=begin TML

Configuration script for Foswiki. Once you have a basic webserver
configuration that lets you access this script, the rest of the
configuration process is done from here.

This script is the dispatcher for several request types, and the container
for session management functions used by all request types.

Detailed TML documentation is available following the  __END__ marker.

=cut

use strict;
use warnings;

{    # Session management constants

    package Foswiki;
    use constant SESSIONEXP  => '60m';    # Lifetime of interactive session
    use constant COOKIEEXP   => '61m';    # Lifetime of cookie
    use constant SAVEEXP     => '5m';     # Lifetime of cached save password
    use constant RESOURCEEXP => '1m';     # Resource access window
    use constant COOKIENAME => 'FOSWIKICFG2SID';

    use constant RESOURCECACHETIME => ( 30 * 24 * 60 * 60 )
      ;                                   # MAX-AGE of cached resources
                                          # in seconds. 0 to disable caching
}

{                                         # Constants that enable debugging code

    package Foswiki;
    use constant SESSIONTRACE   => 0;     # DEBUG temp
    use constant TRANSACTIONLOG => 0;

    # Work-around for https://rt.cpan.org/Public/Bug/Display.html?id=80346
    # (Taint failure when Storable is used for cookies with db_file.)

    #    use constant SESSION_DSN => "driver:file;serializer:default;id:md5";
    use constant RT80346     => 1;
    use constant SESSION_DSN => "driver:file;serializer:storable;id:md5";

    use constant DISPLAY_UNSAVED => 0;
}

sub log;

# This is absolutely essential for error reporting. We load it using
# an eval so we can report the problem.
eval "use CGI::Carp qw(fatalsToBrowser)";
if ($@) {
    print <<"REPORT";
Content-type: text/plain

Could not load CGI::Carp. Please install this module before continuing.
It can be downloaded from http://www.cpan.org

The error seen was:
$@
REPORT
    exit 1;
}

###########################################################
# VERY basic stuff required for configure to work. Any errors
# during this phase will throw a die, which will be picked up
# using CGI::Carp fatalsToBrowser

# Warnings are fatal  confession is good for the soul.
#$SIG{'__WARN__'} = sub { die @_ };
#$SIG{'__WARN__'} = sub { Carp::confess( @_) };

eval 'require 5.00503';
die $@ if $@;

# We warn against running Foswiki on an older Perl version than 5.8.8
# but we will not let configure die in this situation. The user
# may have updated many libraries and tweaked Foswiki so let us give
# him a chance.
my $perlversion = $];
if ( $perlversion < 5.008008 ) {
    print STDERR <<HERE;
Your perl version is older than 5.8.8.
Foswiki has been successfully tested on Perl 5.8.8 and 5.10.X.
Running Foswiki with an older Perl version requires upgrading of modules and
tweaking of the Foswiki code.
HERE
}

# Get web server's user
our $WebServer_uid = '';

eval { $WebServer_uid = getlogin() || getpwuid($>) || ''; };

my $localLibFailure;

sub _loadBasicModule {
    my (@modules) = @_;

    foreach my $module (@modules) {
        eval "use $module";
        if ($@) {
            my $reason = "Failed to load the perl module $module. The module ";

            # See if we can find the .pm on @INC
            my $foundAt = "could not be found. ";
            my $modpath = $module;
            if ( $modpath =~ /^([\w:]+)/ ) {
                $modpath =~ s#::#/#g;
                $modpath .= '.pm';
                foreach my $path (@INC) {
                    if ( -e "$path/$modpath" ) {
                        $foundAt = "was found at $path/$modpath";
                        if ( !-r "$path/$modpath" ) {
                            $foundAt .=
                              ", but I don't have permission to read it.";
                        }
                        last;
                    }
                }
            }
            $reason .= $foundAt;

            $reason .= <<HERE;


Please ensure that:
   1 $module is installed,
   2 that the module is available on the \@INC path,
   3 that the webserver user ($WebServer_uid) has permission to read the $modpath file.
HERE

            $reason .= <<HERE;
The detailed error seen was:
$@
HERE
            if ($localLibFailure) {
                $reason .= <<HERE;

NOTE that I was unable to load LocalLib.cfg because of the following error:

$localLibFailure
HERE
            }
            die $reason;
        }
    }
}

::_loadBasicModule( 'FindBin', 'File::Spec', 'Config', );

# Capture DIE for stack *when debugging*
#$SIG{__DIE__} = sub { Carp::confess( $_[0] || '' ) };
#$SIG{__DIE__} = sub { return if( $^S ); Carp::confess( $_[0] || '' ) };

###########################################################
# Establish the path to the Foswiki library

# Set the working dir to the bin dir
no warnings;
$FindBin::Bin =~ /^(.*)$/;
use warnings;
chdir($1) or die "chdir $1 failed";

my @root = File::Spec->splitdir($1);
my $setlib = File::Spec->catfile( @root, 'setlib.cfg' );
pop(@root);

# Try to load the LocalLib.cfg optional overload
eval "require '$setlib';";
if ($@) {

    # No joy. Remember the failure so we can report it later.
    $localLibFailure = $@;

    # Stick the root/lib on the path; there's a high probability we'll be
    # able to find the bits of Foswiki::Configure that way. We will report
    # the setlib error later.
    unshift( @INC, File::Spec->catfile( @root, 'lib' ) );
}

::_loadBasicModule( 'CGI qw(:any)', 'Foswiki::Configure::CGI', );

$| = 1;    # no buffering on STDOUT

# We are configuring $Foswiki::cfg, so we need to be in package Foswiki from
# now on.
package Foswiki;

# We keep the actual config, and the default from Foswiki.spec, separate
my ( %cfg, $defaultCfg );

# Declared in Foswiki to support checkers
our $query = new CGI;
our $session;

# 'constants' used in Foswiki.spec
my $TRUE  = 1;
my $FALSE = 0;

my $action          = $query->param('action');
my @feedbackHeaders = (
    -type                        => 'application/octet-stream',
    'X-Foswiki-FeedbackResponse' => 'V1.0',
  )
  if ( $query->http('X-Foswiki-FeedbackRequest')
    || $action && $action eq 'feedbackUI' );

our $badLSC;
our $insane;

our $configItemRegex;

our $sanityStatement;
our $unsavedChangesNotice = '';

our $time = time();

our $url        = $query->url();
our $scriptName = Foswiki::Configure::CGI::getScriptName();
our $method     = $query->request_method();
our $pathinfo   = $query->path_info();
our @pathinfo;

$query->delete('action');
{
    my $pinfo = $pathinfo;
    $pinfo =~ s,^/,,;
    @pathinfo = split( '/', $pinfo ) if ( defined $pinfo );
    $action ||= $pathinfo[0] || 'Configure';
}
$action =~ tr/A-Za-z0-9_-//cd;

#$action = 'feedbackUI' if( $action =~ /^test$/i && $method eq 'POST' ); #PATH_INFO test

our $redirect;

my $usePinfo = 01;    # Check for OS/browser issues before turning on?

# generate references to resources
our $resourceURI = $scriptName
  . (
    $usePinfo
    ? "/resource/"
    : "?action=resource&resource="
  );
our $actionURI = $scriptName
  . (
    $usePinfo
    ? "/"
    : "?action="
  );

# htmlResponse flags
use constant MORE_OUTPUT => 100_000;
use constant NO_REDIRECT => 10_000;
use constant ERROR_FORM  => 1_000;

our $MESSAGE_TYPE;
*MESSAGE_TYPE = \$Foswiki::Configure::UI::MESSAGE_TYPE;
*MESSAGE_TYPE = \$Foswiki::Configure::UI::MESSAGE_TYPE;

print STDERR "CFG Entered: '$action' "
  . $query->request_method . " - "
  . $query->url() . " - "
  . ( $query->path_info() || 'mt' ) . ' - '
  . ( $query->cookie(COOKIENAME) || 'nocookie' ) . ' '
  . (
    TRANSACTIONLOG > 1
    ? join( ', ',
        map { ( "$_=" . ( $query->param($_) || 'mt' ) ) } sort $query->param() )
    : ''
  )
  . "\n"
  if (TRANSACTIONLOG);

# Make sure we can handle this request

exists { _getValidActions('_validate') }->{$action} or invalidRequest();

#print STDERR "\nNEW TRANSACTION: $action \n";

our $DEFAULT_FIELD_WIDTH_NO_CSS = '70';

# Minimal modules needed to handle validation (and resources)

::_loadBasicModule(qw/CGI::Session File::Temp CGI::Cookie/);

# Obtain any existing session for validation and authentication

{
    my $sid = $query->cookie(COOKIENAME) || undef;
    if ( defined $sid && $sid =~ m/^([\w_-]+)$/ ) {
        $sid = $1;
    }
    else {
        undef $sid;
    }

    $session =
      CGI::Session->load( SESSION_DSN, $sid,
        { Directory => File::Spec->tmpdir } )
      or die CGI::Session->errstr();

    if ( RT80346 && $session->dataref->{_SESSION_ID} ) {
        $session->dataref->{_SESSION_ID} =~ /^(.*)$/;
        $session->dataref->{_SESSION_ID} = $1;
    }
}
my $cookie = newCookie($session);

# Any redirect action supersedes request

if ( ( $redirect = $session->param('redirect') ) ) {
    print STDERR "Redirect action: $action => $redirect\n" if (TRANSACTIONLOG);
    $action = $redirect;
    $session->clear('redirect');

  # Should always be valid, but in case of a stale session file, we check anyway

    exists { _getValidActions('_validate') }->{$action} or invalidRequest();
}

::_loadBasicModule(
    qw/Foswiki::Configure::Util Foswiki::Configure::TemplateParser/);

# Validate request

dispatch( '_validate', $action, \&invalidDispatch, $session, $cookie );

###########################################################
# From this point on we shouldn't have any more "fatal" (to configure)
# errors, so we can report errors in the browser (i.e. without using die)

_getEnvironmentInfo();

# Load all the bits of the configure module that we explicitly use
# The loadBasicModule does some extra analysis on errors.
::_loadBasicModule(
    qw {
      Cwd
      Data::Dumper
      File::Copy
      Foswiki::Configure::Checker
      Foswiki::Configure::Item
      Foswiki::Configure::Load
      Foswiki::Configure::Pluggable
      Foswiki::Configure::Root
      Foswiki::Configure::Section
      Foswiki::Configure::Type
      Foswiki::Configure::Types::BOOLEAN
      Foswiki::Configure::Types::NUMBER
      Foswiki::Configure::Types::SELECT
      Foswiki::Configure::Types::STRING
      Foswiki::Configure::FoswikiCfg
      Foswiki::Configure::UI
      Foswiki::Configure::UIs::Section
      Foswiki::Configure::Value
      Foswiki::Configure::Valuer
      Foswiki::Configure::GlobalControls
      }
);

# Handle authentication

my $messageType;

dispatch( '_authenticate', $action, sub { htmlResponse( "", 401 ) },
    $session, $cookie );

# Dispatch the action (should not return)

dispatch( '_action', $action, \&invalidDispatch, $session, $cookie );

invalidRequest("$action handling incomplete");

exit(1);

# ######################################################################
# End of the main program; the rest is all subs
# ######################################################################

# Each action has three subroutines that live in Foswiki::
#
# _validateXXX - ensures that the request is acceptable.  May handle
# if GUI isn't required.   Loads any necessary service modules.
#
# _authenticateXXX - ensures that the request is allowable (session, password, etc)
# _actionXXX - actually processes the request
#
# These are called from dispatch().  Any value returned will call an error handler,
# usually invalidRequest, which generates an HTML error page and does not return.
#
# All three routines must exist for each action: implementors must think about each
# request phase.  To add a new action, simply define the three subroutines (there is
# no master list.  The only constraint is that the _validate routine must
# be defined before _getValidActions is called.

# ######################################################################
# Dispatch hooks for each action
# ######################################################################

sub _validateConfigure {
    my ( $action, $session, $cookie ) = @_;

    if ( $method !~ /^(GET|POST)$/ ) {
        invalidRequest( "", 405, Allow => 'GET,POST' );
    }

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

sub _validateSavechanges {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'POST' ) {
        invalidRequest( "", 405, Allow => 'POST' );
    }

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

sub _validateMakemorechanges {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'POST' ) {
        invalidRequest( "", 405, Allow => 'POST' );
    }

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

sub _validateTestEmail {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'POST' ) {
        invalidRequest( "", 405, Allow => 'POST' );
    }

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

sub _validateFindMoreExtensions {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'GET' ) {
        invalidRequest( "", 405, Allow => 'GET' );
    }

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

sub _validateManageExtensions {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'POST' ) {
        invalidRequest( "", 405, Allow => 'POST' );
    }

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

sub _validateManageExtensionsResponse {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'GET' ) {
        invalidRequest( "", 405, Allow => 'GET' );
    }
    invalidRequest( "Not valid interactively", 400 ) unless ($redirect);

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

sub _validatefeedbackUI {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'POST' ) {
        invalidRequest( "", 405, Allow => 'POST' );
    }
    my $version = $query->http('X-Foswiki-FeedbackRequest') || '';
    unless ( $version =~ /^V(\d+)\.(\d+)(\.\d+)?$/ && $1 == 1 ) {
        my $eicon = $Foswiki::resourceURI . "icon_error.png";
        htmlResponse(
            (
qq {<html><head></head><body><div class="configureFeedbackError">
<h1><img src="$eicon">Invalid feedback request</h1>
<p><p><p><strong>Feedback request was not accepted</strong><p>}
                  . (
                    $version
                    ? "Invalid Feedback protocol: $version"
                    : "Unidentified protocol"
                  )
                  . qq{</div></body></html>}
            ),
        );
    }

    ::_loadBasicModule('Foswiki::Configure::Feedback');
    return;
}

# ######################################################################
# Common subroutines
# ######################################################################

# Get the LocalSite.cfg file and .spec files read
# Check for severe errors

sub _loadSiteConfig {

    # Subset UI for these checks

    my $stub = new Foswiki::Configure::Item();
    my $sanityUI = Foswiki::Configure::UI::loadChecker( 'BasicSanity', $stub );

    # This "checker" actually loads the LocalSite.cfg and Foswiki.spec files

    $sanityStatement = $sanityUI->check();

    # Bad LocalSite.cfg, errors (no file, no path, not writable, perl syntax)

    $badLSC = $sanityUI->lscIsBad();
    $insane = $sanityUI->insane();

    return;
}

# Sort a list of hash keys for display

sub sortHashkeyList {
    return map { $_->[0] } sort {
        my @a = @{ $a->[1] };
        my @b = @{ $b->[1] };
        while ( @a && @b ) {
            my $c = shift(@a) cmp shift(@b);
            return $c if ($c);
        }
        return @a <=> @b;
      } map {
        [ $_, [ map { s/(?:^\{)|(?:\}$)//g; $_ } split( /\}\{/, $_ ) ] ]
      } @_;
}

sub _getEnvironmentInfo {

    # Get web server's group info
    $::WebServer_gid = '';
    eval {
        $::WebServer_gid =
          join( ',', map { lc( getgrgid($_) ) } split( ' ', $( ) );
    };
    if ($@) {

        # Try to use Cygwin's 'id' command - may be on the path, since Cygwin
        # is probably installed to supply ls, egrep, etc - if it isn't, give
        # up.
        # Run command without stderr output, to avoid CGI giving error.
        # Get names of primary and other groups.
        # This is down here because it takes 30s to execute on Strawberry perl
        $::WebServer_gid =
          lc(qx(sh -c '( id -un ; id -gn) 2>/dev/null' 2>nul ));
    }

    ###########################################################
    # Grope the OS. This duplicates a bit of code in Foswiki.pm,
    # but it has to be duplicated because we don't want to deal
    # with loading Foswiki just yet.

    unless ( $Foswiki::cfg{DetailedOS} ) {
        $Foswiki::cfg{DetailedOS} = $^O;
        unless ( $Foswiki::cfg{DetailedOS} ) {
            require Config;
            no warnings 'once';
            $Foswiki::cfg{DetailedOS} = $Config::Config{osname};
        }
    }
    unless ( $Foswiki::cfg{OS} ) {
        if ( $Foswiki::cfg{DetailedOS} =~ /darwin/i ) {    # MacOS X
            $Foswiki::cfg{OS} = 'UNIX';
        }
        elsif ( $Foswiki::cfg{DetailedOS} =~ /Win/i ) {
            $Foswiki::cfg{OS} = 'WINDOWS';
        }
        elsif ( $Foswiki::cfg{DetailedOS} =~ /vms/i ) {
            $Foswiki::cfg{OS} = 'VMS';
        }
        elsif ( $Foswiki::cfg{DetailedOS} =~ /bsdos/i ) {
            $Foswiki::cfg{OS} = 'UNIX';
        }
        elsif ( $Foswiki::cfg{DetailedOS} =~ /dos/i ) {
            $Foswiki::cfg{OS} = 'DOS';
        }
        elsif ( $Foswiki::cfg{DetailedOS} =~ /^MacOS$/i ) { # MacOS 9 or earlier
            $Foswiki::cfg{OS} = 'MACINTOSH';
        }
        elsif ( $Foswiki::cfg{DetailedOS} =~ /os2/i ) {
            $Foswiki::cfg{OS} = 'OS2';
        }
        else {
            $Foswiki::cfg{OS} = 'UNIX';
        }
    }

    # Remember what we detected previously, for use by Checkers
    if ( $scriptName =~ /(\.\w+)$/ ) {
        $Foswiki::cfg{DETECTED}{ScriptExtension} = $1;
    }
}

# ######################################################################
# Unsaved changes report
# ######################################################################

sub unsavedChangesNotice {
    my $updated = shift;

    # Remove any {ConfigureGUI} pseudo-keys from %updated and count the rest.

    my $pending = 0;
    foreach my $keys ( keys %$updated ) {
        if ( $keys =~ /^\{ConfigureGUI\}/ ) {
            delete $updated->{$keys};
        }
        else {
            $pending++;
        }
    }
    my @pendingItems = map { { item => $_ } } sortHashkeyList( keys %$updated )
      if (DISPLAY_UNSAVED);

    my $pendingHtml =
      Foswiki::Configure::UI::getTemplateParser()
      ->readTemplate('feedbackunsaved');
    $pendingHtml = Foswiki::Configure::UI::getTemplateParser()->parse(
        $pendingHtml,
        {
            pendingCount => $pending,
            listPending  => DISPLAY_UNSAVED,
            pendingItems => \@pendingItems,
        }
    );
    Foswiki::Configure::UI::getTemplateParser()
      ->cleanupTemplateResidues($pendingHtml);

    return $pendingHtml;
}

# ######################################################################
# log an error
# ######################################################################

sub log {
    my ($message) = @_;

    $message ||= '';
    my $log = $Foswiki::cfg{DebugFileName} || 'ConfigureError.log';
    my $file;
    if ( open( $file, '>>', $log ) ) {
        print $file "$message\n";
        close($file);
    }
}

# ######################################################################
# Load a UI with extra diagnostics on failure
# ######################################################################

sub _checkLoadUI {
    my ( $uiname, $root ) = @_;
    my $ui = eval { Foswiki::Configure::UI::loadUI( $uiname, $root ) };
    unless ($ui) {
        my $msg = "Could not load $uiname UI. Error was: <pre>$@</pre>";
        if ( $@ =~ /Can't locate (\S+)/ ) {
            $msg .= << "HERE";
You may be able to correct this error by installing the missing $1 module.
HERE

        }
        htmlResponse( $msg, ERROR_FORM );
    }
    return $ui;
}

sub _validateLogout {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'POST' ) {
        invalidRequest( "", 405, Allow => 'POST' );
    }

    ::_loadBasicModule('Foswiki::Configure::MainScreen');
    return;
}

# ######################################################################
# Resource server
# ######################################################################

# This is the most frequently invoked function (every icon, image,etc).
# To keep it relatively fast, it lives in the main module, and executes
# before the heavyweight UI components are loaded.

# Request validator

sub _validateresource {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'GET' ) {
        invalidRequest( "", 405, Allow => 'GET' );
    }

    my $resource = $query->param('resource') || $pathinfo[1];

    defined($resource) or return "No resource specified";

    if ( $resource =~ /^((?:[-\w_]+\.)+\w+)$/ ) {    # filter-in and untaint
        $resource = $1;
    }
    else {
        return "Invalid resource name";
    }

    # Resources don't need the GUI, so authenticate and handle the action here

    dispatch( '_authenticate', 'resource', \&invalidDispatch, $session );
    goto &_actionresource;
}

# Request authenticator

sub _authenticateresource {
    my ( $action, $session, $cookie ) = @_;

    # Must have an established session (not necessarily logged-in)
    # This prevents resource requests not preceeded by another action

    if (  !$session
        || $session->is_expired
        || !loggedIn($session)
        && !activeSession($session)
        && !$session->is_new )
    {
        invalidRequest( "", 401 );
    }
    refreshSession($session);

    return;
}

# Request handler

sub _actionresource {

    #    my( $action, $session, $cookie ) = @_;

    my $resource = $query->param('resource') || $pathinfo[1];

    defined($resource) or return "No resource specified";

    $resource =~ /^([-\w._]+\.\w+)$/
      or return "Invalid resource name $resource";    # filter-in and untaint
    $resource = $1;

    #ignore $query->param('type') and set it using the extension
    my $type = 'text/plain; charset=UTF-8';
    if ( $resource =~ /\.([^.]+)$/ ) {
        $type = {
            bmp  => 'image/x-ms-bmp',
            css  => 'text/css; charset=UTF-8',
            htm  => 'text/html; charset=UTF-8',
            html => 'text/html; charset=UTF-8',
            ico  => 'image/vnd.microsoft.icon',

            #                ico => 'image/x-icon',
            gif  => 'image/gif',
            jpg  => 'image/jpeg',
            jpeg => 'image/jpeg',
            js   => 'text/javascript; charset=UTF-8',
            png  => 'image/png',
            rgb  => 'image/rgb',
            tiff => 'image/tiff',
            xbm  => 'image/x-bitmap',
            xpm  => 'image/x-pixmap',
          }->{$1}
          || $type;
    }

    # We get the data unconditionally as we need to recompute
    # the validators.  Should be relatively cheap.
    # We will zip on demand for text/* content.

    my $parser = Foswiki::Configure::TemplateParser->new;
    my $zipok;
    my $text = ( $type =~ m,^text/, );
    if ($text) {
        my @accept = split( /,\s*/, ( $query->http('Accept-Encoding') || '' ) );
        foreach my $accept (@accept) {
            if ( $accept =~ /^(?:(?:gzip|\*)(?:\s*;\s*q=\d+(?:\.\d+)?)?)\s*$/ )
            {
                $zipok = 1;
                last;
            }
        }
    }

    # Note that only static variables are allowed here (such as the
    # WIKI's URI, as resources are cachable.  If they change once in
    # a while, a browser REFRESH will re-validate, and the ETag will
    # ensure that updated data is provided.  In particular, this
    # allows .css files to contain URIs (e.g. for background images.)
    # and still be cached.  Don't add anything dynamic.

    ( $text, my $etag, my $zipped ) = $parser->getResource(
        $resource,
        -etag       => 1,
        -binmode    => !$text,
        -zipok      => $zipok,
        RESOURCEURI => $resourceURI
    );

    defined $etag or htmlResponse( "$resource not found", 404 );

    my @headers = ( ETag => $etag );

    # Cache control mut be private because cookies are required to authenticate
    # resource requests.

    push @headers,
      (
        RESOURCECACHETIME > 0
        ? (
            Cache_Control => ( 'private, max-age=' . RESOURCECACHETIME ),
            -expires      => ( '+' . RESOURCECACHETIME . 's' ),
          )
        : (
            Cache_Control => 'no-cache',
            -expires      => '-1d',
        )
      );

    # See if we really need to send this
    # If the browser sent an ETag for this resource, and
    # it matches the current tag, we don't.
    # ETags are opaque; just an optional strength indicator
    # and a quoted string.  A browser may cache several
    # versions of a resource and thus send several
    # ETag candidates.  We return the one (if any) that
    # matches the current state.  (E.g. variable substitution)
    #
    # Note that we must not return entity headers with a weak validator and
    # should not for a strong one.  So we dont.

    if ( ( my $htags = $query->http('If-None-Match') ) ) {
        foreach my $htag ( split /\s*,\s*/, $htags ) {
            $htag =~ m,^\s*((?:W/)?"[^"]+")\s*$, or next;
            if ( $1 eq $etag ) {
                htmlResponse( '', 304, @headers );
            }
        }
    }

    push @headers, ( Content_Encoding => 'gzip' )
      if ($zipped);
    push @headers, ( Content_Type => $type );
    htmlResponse( $text, 200, @headers );
}

# ######################################################################
# Session management
# ######################################################################

# ######################################################################
# Establish a session
# ######################################################################

sub establishSession {
    my ( $session, $cookie ) = @_;

    if ( $session->is_empty ) {
        $session = $session->new($session) or die CGI::Session->errstr();
        $cookie  = newCookie($session);
        $_[0]    = $session;
        $_[1]    = $cookie;

        if (RT80346) {
            $session->dataref->{_SESSION_ID} =~ /^(.*)$/;
            $session->dataref->{_SESSION_ID} = $1;
        }
    }
    print STDERR "Strace: Establish "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . ' '
      . $session->id . ' '
      . ( $session->param('_PASSWD_OK') || 'f' )
      . ( $session->param('_SAVE_OK')   || 'f' ) . "\n"
      if (SESSIONTRACE);
}

# Session state variables.
# Note that these variables all auto-expire

# ######################################################################
# See if logged-in
# ######################################################################

sub loggedIn {
    my $session = shift;

    print STDERR "Strace: Islog "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . "\n"
      if (SESSIONTRACE);
    return 1 if ( $session->param('_PASSWD_OK') );

    return 0 unless ( $query->auth_type() );    # Basic, Digest, ...

    return 0
      unless ( $Foswiki::cfg{Password} && !$query->param('changePassword') );

    refreshLoggedIn($session);                  # OK to rely on browser

    return 1;
}

sub refreshLoggedIn {
    my $session = shift;

    print STDERR "Strace: Reflog "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . "\n"
      if (SESSIONTRACE);
    $session->param( '_PASSWD_OK', 1 );
    $session->expires( '_PASSWD_OK', SESSIONEXP );

    return 1;
}

# ######################################################################
# See if save permitted
# ######################################################################

sub saveAuthorized {
    my $session = shift;

    print STDERR "Strace: isSave "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . "\n"
      if (SESSIONTRACE);
    return $session->param('_SAVE_OK');
}

sub refreshSaveAuthorized {
    my $session = shift;

    print STDERR "Strace: Refsave "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . "\n"
      if (SESSIONTRACE);
    $session->param( '_SAVE_OK', 1 );
    $session->expires( '_SAVE_OK', SAVEEXP );

    return 1;
}

# ######################################################################
# See if resource access is allowed
# ######################################################################

sub activeSession {
    my $session = shift;

    print STDERR "Strace: Isact "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . "\n"
      if (SESSIONTRACE);
    return $session->param('_RES_OK');
}

sub refreshSession {
    my $session = shift;

    print STDERR "Strace: refact "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . "\n"
      if (SESSIONTRACE);
    $session->param( '_RES_OK', 1 );
    $session->expires( '_RES_OK', RESOURCEEXP );

    return 1;
}

# ######################################################################
# close session (e.g. logout)
# ######################################################################

sub closeSession {
    my ( $session, $cookie ) = @_;

    print STDERR "Strace: close "
      . join( ', ', ( caller(1) )[ 0, 3, 1, 2 ] ) . "\n"
      if (SESSIONTRACE);

    $session->clear(
        [qw/_PASSWD_OK _SAVE_OK _RES_OK redirect redirectResults/] );

    #    $session->delete;

    return;
}

# ######################################################################
# create a new cookie
# ######################################################################

sub newCookie {
    my $session = shift;

    my @pars = ( -name => COOKIENAME, -value => $session->id );
    push @pars, -secure => 1 if ( $ENV{HTTPS} && $ENV{HTTPS} eq 'on' );
    push @pars, -path => $scriptName if ($scriptName);
    push @pars, -expires => "+" . COOKIEEXP;
    $cookie = CGI->cookie(@pars);
    return $cookie;
}

# ######################################################################
# Request handling infrastructure
# ######################################################################

# Dispatch a request to a handler, reporting any error

sub dispatch {

    #    my( $type, $action, $errsub, @args );

    my $type   = shift;
    my $action = shift;
    my $errsub = shift or die "No errsub for $action\n";

    my %dispatch = _getValidActions($type);

    my $handler = $dispatch{$action} or invalidRequest();

    my $error = $handler->( $action, @_ );
    return 1 unless ($error);

    return $errsub->( $error, @_ );
}

# Not that it's a good idea:

sub ignoreError {
    return;
}

# ######################################################################
# Handle an invalid dispatch
# ######################################################################

sub invalidDispatch {
    my $error  = shift;
    my $type   = shift;
    my $action = shift;

    defined $error or $error = "";
    invalidRequest( "Invalid Dispatch $type/$action $error", 400 );
}

# ######################################################################
# Terminate request with a simple HTML response
# ######################################################################

sub invalidRequest {
    my $reason = shift || "The specified request ($action) is invalid";
    my $status = shift;
    $status = 400 unless ( defined $status );

    htmlResponse( $reason, $status + ERROR_FORM, @_ );
}

# ######################################################################
# Standard HTML response
# ######################################################################

# All responses come thru here (or should)
#
# Special handling is encoded in status (evaluated in order):
#   o Routine exits unless the status is 1xx_xxx
#   o POST responses are redirected unless the status is 1x_xxx
#   o Error screens are built if the status is 1_xxx;
#   o The actual status is in the low 3 decimal digits
#
# The session cookie is applied if we have one

sub htmlResponse {
    my $reason = shift;
    my $status = shift || 200;

    # See 'use constants' at # htmlResponse flags near top of file

    my $flags = sprintf( "%08u", $status / 1000 );
    $status %= 1000;
    $status ||= 200;

    my ( $moreOutput, $noRedirect, $errForm ) = $flags =~ /(.)(.)(.)$/;
    $noRedirect = 1 if (@feedbackHeaders);

    if ( $method eq 'POST' && !$noRedirect ) {
        htmlRedirect(
            'DisplayResults',
            {
                reason => $reason,
                status => $status,
                args   => [@_],
            }
        );
    }

    my $sts = {
        200 => { msg => 'OK', hdr => 'Request succeeded' },
        304 => { msg => 'Not Modified' },
        400 => { msg => 'Invalid Request' },
        401 => { msg => 'Not authorized' },
        404 => { msg => 'Not found' },
        405 => { msg => "Method $method not allowed" },
      }->{$status}
      or die "Invalid status";

    my $html = '';

    if ($errForm) {
        $sts->{hdr} = 'Request failed' if ( $status == 200 );
        $sts->{hdr} = $sts->{msg} unless ( exists $sts->{hdr} );
        $html .= CGI::start_html();
        $html .= CGI::h1( $sts->{hdr} );
        $html .= CGI::p($reason) if ($reason);
        $html .= CGI::end_html();
    }
    else {
        $html .= $reason;
    }

    # Default handling for cache control and content encoding
    # Output is non-cachable (except resources)
    # Gzip output if possible, unless more is coming from elsewhere.
    # Resource decision to zip is more complex; it's already done.

    unless ( $action eq 'resource' ) {
        push @_,
          (
            Cache_Control => 'no-cache',
            -expires      => '-1d',
          );

        unless ( $moreOutput || length($html) < 2048 ) {
            my @accept =
              split( /,\s*/, ( $query->http('Accept-Encoding') || '' ) );
            foreach my $accept (@accept) {
                if ( $accept =~
                    /^(?:(?:gzip|\*)(?:\s*;\s*q=\d+(?:\.\d+)?)?)\s*$/ )
                {
                    eval "use IO::Compress::Gzip ();";
                    last if ($@);
                    no warnings 'once';
                    my $data = $html;
                    undef $html;
                    no warnings 'once';
                    IO::Compress::Gzip::gzip( \$data, \$html )
                      or die
"Unable to gzip response: $IO::Compress::Gzip::GzipError\n";
                    push @_, ( Content_Encoding => 'gzip' );
                    last;
                }
            }
        }
    }

    # With the data in final form, header can be generated.

    push @_, -cookie => $cookie if ( defined $cookie && $session );

    unshift @_, ( Content_Length => length($html) )
      unless ($moreOutput);

    $html = $query->header(
        -status       => "$status " . $sts->{msg},
        -Content_type => 'text/html; charset=utf8',
        @feedbackHeaders, @_,
    ) . $html;

    if ($session) {
        refreshSession($session);
        $session->flush;
    }

    print $html;

    exit unless ($moreOutput);
}

# ######################################################################
# Redirect to the main script to retrieve results
# ######################################################################

# $action is the command to be executed
# Other arguments are joined if there are more than one.
# If only one, it can be a hash or other structure.
# These are saved in the sesson for retrieval by the GET
# Does not return.

sub htmlRedirect {
    my $action = shift;
    my $content = ( @_ == 1 ? $_[0] : join( '', @_ ) );

    if ($session) {
        $session->param( 'redirectResults', $content );
        $session->param( 'redirect',        $action );
        refreshSession($session);
    }

    rawRedirect($scriptName);
}

# ######################################################################
# Retrieve results of redirect (and clear)
# ######################################################################

sub redirectResults {
    my $results = $session->param('redirectResults');
    $session->clear('redirectResults');

    return $results;
}

# ######################################################################
# Redirect anywhere
# ######################################################################

sub rawRedirect {
    my $destination = shift;

    if ($session) {
        $session->flush;
    }

    my $body = << "REDIRECT";
<html><head></head><body>Results at <a href="$destination">$destination</a></body></html>
REDIRECT

    print $query->redirect(
        -uri            => $destination,
        -status         => '303 Results ready',
        -Content_Type   => 'text/html; charset=utf8',
        -Content_Length => length($body),
        @feedbackHeaders, @_
    ), $body;

    exit;
}

# ######################################################################
# Display results in response to a redirect
# ######################################################################

sub _validateDisplayResults {
    my ( $action, $session, $cookie ) = @_;

    if ( $query->request_method() ne 'GET' ) {
        invalidRequest( "", 405, Allow => 'GET' );
    }

    my $results = redirectResults();
    invalidRequest("Bad redirect or use of BACK")
      unless ( $results && ref($results) eq 'HASH' );
    htmlResponse( $results->{reason}, $results->{status},
        @{ $results->{args} } );
}

sub _authenticateDisplayResults {
    my ( $action, $session, $cookie ) = @_;
    die;
}

sub _actionDisplayResults {
    my ( $action, $session, $cookie ) = @_;
    die;
}

# ######################################################################
# Return list of valid action routines suitable for dispatching
# ######################################################################

# N.B. This must be AFTER all _actionXX routines have been declared.
# It should be the last module in this file.

sub _getValidActions {
    my $prefix = shift;

    no strict 'refs';
    return map {
            ( /^$prefix(.*)$/ && ref( *{$_}{CODE} ) eq 'CODE' )
          ? ( $1 => *{$_}{CODE} )
          : ()
      }
      keys %Foswiki::;
}

1;
__END__

=begin TML

The script works from the top down, by checking features of the
environment before moving on. The sequence is:
   1. Check the version of perl
   2. Check we have the modules to run this script
   3. Check the environment
   4. Check we have the modules to load the rest of configure
... and so on. At any stage, the script reports any errors in the
best way it can given the environment established so far.
When the basic checks are complete, the script moves into the
real configuration steps; setting configuration variables.

This phase of the configure environment follows a Model-View-
Controller pattern.

---++ Controller
This script is the controller; it handles communication with the
browser (and thus the user). Communication is very simple; this script
is re-invoked with different 'action' parameters to determine what it does.

---++ Model
The Model consists of a simple node tree, where each node represents a
structural element in the *presentation* of the configuration (this may
not be consistent with the structure of $Foswiki:cfg, so beware). Each
leaf node has an associated Type (in the Types subdirectory) that has
collected model and view behaviours for the basic types.

Class hierarchy
  * Foswiki::Configure::Item
     * Foswiki::Configure::Value - a leaf value
     * Foswiki::Configure::Section - a running node
        * Foswiki::Configure::Root - a root section
        * Foswiki::Configure::Pluggable - a plug-in subsection
           * Foswiki::Configure::Pluggables::FINDEXTENSIONS - etc
        * Foswiki::Configure::Checkers::Introduction - should be a Pluggable
        * Foswiki::Configure::Checkers::Welcome - should be a Pluggable
        * Foswiki::Configure::Checkers::MSWin32 - should be a Pluggable
The Model is independent of the language used to represent the
configuration. There is one parser/generator provided, FoswikiCfg, but it
would be trivial to add others.

---++ View
The View is a DOM document, generated as HTML by a set of UI classes,
all subclasses of Foswiki::Configure::UI. The UI classes visit the
model in order to generate the HTML.

---+++ UIs
Each class in the model (Root, Section, Value, Item) has a corresponding UI
decorator object, which renders HTML for the model. There are also a
number of bespoke UIs, some of which assist =configure= in the generation
of full screens (Introduction, Welcome, AUTH, UPDATE, EXTEND, EXTENSIONS,
UPDATE) and others which relate to the Pluggables (FINDEXTENSIONS, LANGUAGES,
PLUGINS). The special UI CGISetup is a specialised Section focused on groping
the CGI configuration. Several of the bespoke UIs (CGISetup, Introduction,
Welcome) have corresponding Checkers, which act as placeholders in the
model for these sections.

Class hierarchy
   * Foswiki::Configure::UI
      * Foswiki::Configure::Checker
         * Foswiki::Configure::Checkers::* - see below
      * Foswiki::Configure::UIs::* - components used in building screens
         * Foswiki::Configure::UIs::Item
            * Foswiki::Configure::UIs::Section
               * Foswiki::Configure::UIs::Root
               * Foswiki::Configure::UIs::Introduction
               * Foswiki::Configure::UIs::Welcome
               * Foswiki::Configure::UIs::MSWin32
               * Foswiki::Configure::UIs::* - other UIs for Pluggables and screens
            * Foswiki::Configure::UIs::Value

---+++ Checkers
Checkers give checking and guessing support for configuration values. Checkers
are all subclasses of Foswiki::Configure::Checker, and inhabit a class
hierarchy under it that mirrors the organisation of configuration keys in
Foswiki.spec.  Checkers include read-only checking UI used for checking
environment sanity (BasicSanity)

Note that when configure is run for the first time (before LocalSite.cfg
has been created) then only the first section of Foswiki.spec is loaded,
and thus checkers only for that subset will be created and run. This means
that on some platforms, initial configuration is a two-phase process, as
the initial path checks are performed on the first run, and only on the
second run, when LocalSite.cfg exists, are the other checkers built and
invoked. This needs improving on.

---+++ Types
Types provide some UI support in the form of type-specific prompters.
This is really an abuse of the Model, but it saves creating
decorator classes for all the Model types.

HTML is generated for the model using Visitor pattern. Each node in the tree
is visited in depth-first order.

Class hierarchy
   * Foswiki::Configure::Type - base
      * Foswiki::Configure::Types::NUMBER - numerical type (perl float values)
         * Foswiki::Configure::Types::OCTAL - octal (permissions)
      * Foswiki::Configure::Types::BOOLEAN - boolean type
         * Foswiki::Configure::Types::LANGUAGE
      * Foswiki::Configure::Types::PERL - perl structure
      * Foswiki::Configure::Types::SELECT - select from a list of values
         * Foswiki::Configure::Types::SELECTCLASS - select a class from a path
      * Foswiki::Configure::Types::STRING - string type
         * Foswiki::Configure::Types::REGEX - regular expression
         * Foswiki::Configure::Types::COMMAND - shell command
         * Foswiki::Configure::Types::PASSWORD - hidden password
         * Foswiki::Configure::Types::PATH - file path (/)
         * Foswiki::Configure::Types::URL - absolute url path (/)
         * Foswiki::Configure::Types::URLPATH - relative url path (/)
      * Foswiki::Configure::Types::UNKNOWN - unknown type

TODO:
The type classes are the obvious place to attach client-side javascript
validators, thus releasing the server-side checkers to consider the "deeper"
issues.

=cut

__END__
Foswiki - The Free and Open Source Wiki, http://foswiki.org/

Copyright (C) 2008-2010 Foswiki Contributors. Foswiki Contributors
are listed in the AUTHORS file in the root of this distribution.
NOTE: Please extend that file, not this notice.

Additional copyrights apply to some or all of the code in this
file as follows:

Copyright (C) 2000-2007 TWiki Contributors. All Rights Reserved.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version. For
more details read LICENSE in the root of this distribution.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

As per the GPL, removal of this notice is prohibited.
